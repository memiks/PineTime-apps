#![feature(prelude_import)]
//! LittlevGL (LVGL) API for Rust. Contains Rust bindings for LittlevGL API for C, generated by `bindgen`.
//! Also includes safe versions of LittlevGL APIs created specially for Rust.

#![no_std]
//  Don't link with standard Rust library, which is not compatible with embedded systems
#![feature(const_transmute)]
//  Allow `transmute` for initialising Lvgl structs
#![feature(trace_macros)]
//  Enable tracing of macros
#![feature(proc_macro_hygiene)]
#[prelude_import]
use core::prelude::v1::*;
#[macro_use]
extern crate core;
#[macro_use]
extern crate compiler_builtins;
//  Allow proc macros to be unhygienic

extern crate macros as lvgl_macros;
//  Import Procedural Macros from `macros` library

//  Allow unused imports
#[allow(unused_imports)]
pub mod core {
    //  Lvgl Core API. Export folder `core` as Rust module `lvgl::core`

    //  TODO: pub mod draw;           //  Lvgl Draw API. Export folder `draw` as Rust module `lvgl::draw`
    //  TODO: pub mod font;           //  Lvgl Font API. Export folder `font` as Rust module `lvgl::font`
    //  TODO: pub mod hal;            //  Lvgl HAL API. Export folder `hal` as Rust module `lvgl::hal`
    //  TODO: pub mod misc;           //  Lvgl Misc API. Export folder `misc` as Rust module `lvgl::misc`

    //  Allow unused imports
    //  Lvgl Objx API. Export folder `objx` as Rust module `lvgl::objx`

    //  TODO: pub mod themes;         //  Lvgl Themes API. Export folder `themes` as Rust module `lvgl::themes`

    //  Allow macros from Rust module `util`
    //  Lvgl Utility API. Export folder `util` as Rust module `lvgl::util`

    //  Lvgl Console API. Export `console.rs` as Rust module `lvgl::console`


    //  Allow type names to have non-camel case




    //  TODO

    //  Strn may be copied

    //  StrnRep may be copied

    //  Last byte must be 0.



    //  Last byte must be 0.
    //  Don't count the terminating null.
    //  Look for the null termination.
    //  String too long


    //  Last byte must be 0.

    //  Last byte must be 0.
    //  Not implemented

    //  Last byte must be 0.

    //  Last byte must be 0.





    //! LittlevGL (LVGL) Core API for Rust
    use crate::{result::*, Out, Ptr, Strn};
    /// Contains Rust bindings for LittlevGL (LVGL) Core API `lv_core`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod obj {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        #[repr(C)]
        pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
        impl <T> __BindgenUnionField<T> {
            #[inline]
            pub fn new() -> Self {
                __BindgenUnionField(::core::marker::PhantomData)
            }
            #[inline]
            pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
            #[inline]
            pub unsafe fn as_mut(&mut self) -> &mut T {
                ::core::mem::transmute(self)
            }
        }
        impl <T> ::core::default::Default for __BindgenUnionField<T> {
            #[inline]
            fn default() -> Self { Self::new() }
        }
        impl <T> ::core::clone::Clone for __BindgenUnionField<T> {
            #[inline]
            fn clone(&self) -> Self { Self::new() }
        }
        impl <T> ::core::marker::Copy for __BindgenUnionField<T> { }
        impl <T> ::core::fmt::Debug for __BindgenUnionField<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>)
             -> ::core::fmt::Result {
                fmt.write_str("__BindgenUnionField")
            }
        }
        impl <T> ::core::hash::Hash for __BindgenUnionField<T> {
            fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) { }
        }
        impl <T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
            fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
        }
        impl <T> ::core::cmp::Eq for __BindgenUnionField<T> { }
        pub const LV_CONF_INCLUDE_SIMPLE: u32 = 1;
        pub const LV_LVGL_H_INCLUDE_SIMPLE: u32 = 1;
        pub const LV_HOR_RES_MAX: u32 = 240;
        pub const LV_VER_RES_MAX: u32 = 240;
        pub const LV_COLOR_DEPTH: u32 = 16;
        pub const LV_COLOR_16_SWAP: u32 = 1;
        pub const LV_COLOR_SCREEN_TRANSP: u32 = 0;
        pub const LV_INDEXED_CHROMA: u32 = 1;
        pub const LV_ANTIALIAS: u32 = 1;
        pub const LV_DISP_DEF_REFR_PERIOD: u32 = 30;
        pub const LV_DPI: u32 = 298;
        pub const LV_MEM_CUSTOM: u32 = 0;
        pub const LV_MEM_SIZE: u32 = 4096;
        pub const LV_MEM_ADR: u32 = 0;
        pub const LV_MEM_AUTO_DEFRAG: u32 = 1;
        pub const LV_ENABLE_GC: u32 = 0;
        pub const LV_INDEV_DEF_READ_PERIOD: u32 = 30;
        pub const LV_INDEV_DEF_DRAG_LIMIT: u32 = 10;
        pub const LV_INDEV_DEF_DRAG_THROW: u32 = 20;
        pub const LV_INDEV_DEF_LONG_PRESS_TIME: u32 = 400;
        pub const LV_INDEV_DEF_LONG_PRESS_REP_TIME: u32 = 100;
        pub const LV_USE_ANIMATION: u32 = 1;
        pub const LV_USE_SHADOW: u32 = 1;
        pub const LV_USE_GROUP: u32 = 1;
        pub const LV_USE_GPU: u32 = 0;
        pub const LV_USE_FILESYSTEM: u32 = 0;
        pub const LV_USE_USER_DATA: u32 = 1;
        pub const LV_IMG_CF_INDEXED: u32 = 1;
        pub const LV_IMG_CF_ALPHA: u32 = 1;
        pub const LV_IMG_CACHE_DEF_SIZE: u32 = 1;
        pub const LV_TICK_CUSTOM: u32 = 1;
        pub const LV_TICK_CUSTOM_INCLUDE: &'static [u8; 9usize] =
            b"xtimer.h\0";
        pub const LV_USE_LOG: u32 = 0;
        pub const LV_USE_DEBUG: u32 = 0;
        pub const LV_THEME_LIVE_UPDATE: u32 = 0;
        pub const LV_USE_THEME_TEMPL: u32 = 0;
        pub const LV_USE_THEME_DEFAULT: u32 = 0;
        pub const LV_USE_THEME_ALIEN: u32 = 0;
        pub const LV_USE_THEME_NIGHT: u32 = 0;
        pub const LV_USE_THEME_MONO: u32 = 0;
        pub const LV_USE_THEME_MATERIAL: u32 = 0;
        pub const LV_USE_THEME_ZEN: u32 = 0;
        pub const LV_USE_THEME_NEMO: u32 = 0;
        pub const LV_FONT_ROBOTO_12: u32 = 0;
        pub const LV_FONT_ROBOTO_16: u32 = 0;
        pub const LV_FONT_ROBOTO_22: u32 = 0;
        pub const LV_FONT_ROBOTO_28: u32 = 1;
        pub const LV_FONT_ROBOTO_12_SUBPX: u32 = 1;
        pub const LV_FONT_ROBOTO_28_COMPRESSED: u32 = 1;
        pub const LV_FONT_UNSCII_8: u32 = 0;
        pub const LV_FONT_FMT_TXT_LARGE: u32 = 0;
        pub const LV_FONT_SUBPX_BGR: u32 = 0;
        pub const LV_TXT_BREAK_CHARS: &'static [u8; 8usize] = b" ,.;:-_\0";
        pub const LV_TXT_LINE_BREAK_LONG_LEN: u32 = 12;
        pub const LV_TXT_LINE_BREAK_LONG_PRE_MIN_LEN: u32 = 3;
        pub const LV_TXT_LINE_BREAK_LONG_POST_MIN_LEN: u32 = 3;
        pub const LV_TXT_COLOR_CMD: &'static [u8; 2usize] = b"#\0";
        pub const LV_USE_BIDI: u32 = 0;
        pub const LV_SPRINTF_CUSTOM: u32 = 0;
        pub const LV_USE_OBJ_REALIGN: u32 = 1;
        pub const LV_USE_ARC: u32 = 1;
        pub const LV_USE_BAR: u32 = 1;
        pub const LV_USE_BTN: u32 = 1;
        pub const LV_BTN_INK_EFFECT: u32 = 0;
        pub const LV_USE_BTNM: u32 = 1;
        pub const LV_USE_CALENDAR: u32 = 1;
        pub const LV_USE_CANVAS: u32 = 1;
        pub const LV_USE_CB: u32 = 1;
        pub const LV_USE_CHART: u32 = 1;
        pub const LV_CHART_AXIS_TICK_LABEL_MAX_LEN: u32 = 20;
        pub const LV_USE_CONT: u32 = 1;
        pub const LV_USE_CPICKER: u32 = 1;
        pub const LV_USE_DDLIST: u32 = 1;
        pub const LV_DDLIST_DEF_ANIM_TIME: u32 = 200;
        pub const LV_USE_GAUGE: u32 = 1;
        pub const LV_USE_IMG: u32 = 1;
        pub const LV_USE_IMGBTN: u32 = 1;
        pub const LV_IMGBTN_TILED: u32 = 0;
        pub const LV_USE_KB: u32 = 1;
        pub const LV_USE_LABEL: u32 = 1;
        pub const LV_LABEL_DEF_SCROLL_SPEED: u32 = 25;
        pub const LV_LABEL_WAIT_CHAR_COUNT: u32 = 3;
        pub const LV_LABEL_TEXT_SEL: u32 = 0;
        pub const LV_LABEL_LONG_TXT_HINT: u32 = 0;
        pub const LV_USE_LED: u32 = 1;
        pub const LV_USE_LINE: u32 = 1;
        pub const LV_USE_LIST: u32 = 1;
        pub const LV_LIST_DEF_ANIM_TIME: u32 = 100;
        pub const LV_USE_LMETER: u32 = 1;
        pub const LV_USE_MBOX: u32 = 1;
        pub const LV_USE_PAGE: u32 = 1;
        pub const LV_PAGE_DEF_ANIM_TIME: u32 = 400;
        pub const LV_USE_PRELOAD: u32 = 1;
        pub const LV_PRELOAD_DEF_ARC_LENGTH: u32 = 60;
        pub const LV_PRELOAD_DEF_SPIN_TIME: u32 = 1000;
        pub const LV_USE_ROLLER: u32 = 1;
        pub const LV_ROLLER_DEF_ANIM_TIME: u32 = 200;
        pub const LV_ROLLER_INF_PAGES: u32 = 7;
        pub const LV_USE_SLIDER: u32 = 1;
        pub const LV_USE_SPINBOX: u32 = 1;
        pub const LV_USE_SW: u32 = 1;
        pub const LV_USE_TA: u32 = 1;
        pub const LV_TA_DEF_CURSOR_BLINK_TIME: u32 = 400;
        pub const LV_TA_DEF_PWD_SHOW_TIME: u32 = 1500;
        pub const LV_USE_TABLE: u32 = 1;
        pub const LV_TABLE_COL_MAX: u32 = 12;
        pub const LV_USE_TABVIEW: u32 = 1;
        pub const LV_TABVIEW_DEF_ANIM_TIME: u32 = 300;
        pub const LV_USE_TILEVIEW: u32 = 1;
        pub const LV_TILEVIEW_DEF_ANIM_TIME: u32 = 300;
        pub const LV_USE_WIN: u32 = 1;
        pub const LV_SYMBOL_AUDIO: &'static [u8; 4usize] = b"\xEF\x80\x81\0";
        pub const LV_SYMBOL_VIDEO: &'static [u8; 4usize] = b"\xEF\x80\x88\0";
        pub const LV_SYMBOL_LIST: &'static [u8; 4usize] = b"\xEF\x80\x8B\0";
        pub const LV_SYMBOL_OK: &'static [u8; 4usize] = b"\xEF\x80\x8C\0";
        pub const LV_SYMBOL_CLOSE: &'static [u8; 4usize] = b"\xEF\x80\x8D\0";
        pub const LV_SYMBOL_POWER: &'static [u8; 4usize] = b"\xEF\x80\x91\0";
        pub const LV_SYMBOL_SETTINGS: &'static [u8; 4usize] =
            b"\xEF\x80\x93\0";
        pub const LV_SYMBOL_HOME: &'static [u8; 4usize] = b"\xEF\x80\x95\0";
        pub const LV_SYMBOL_DOWNLOAD: &'static [u8; 4usize] =
            b"\xEF\x80\x99\0";
        pub const LV_SYMBOL_DRIVE: &'static [u8; 4usize] = b"\xEF\x80\x9C\0";
        pub const LV_SYMBOL_REFRESH: &'static [u8; 4usize] =
            b"\xEF\x80\xA1\0";
        pub const LV_SYMBOL_MUTE: &'static [u8; 4usize] = b"\xEF\x80\xA6\0";
        pub const LV_SYMBOL_VOLUME_MID: &'static [u8; 4usize] =
            b"\xEF\x80\xA7\0";
        pub const LV_SYMBOL_VOLUME_MAX: &'static [u8; 4usize] =
            b"\xEF\x80\xA8\0";
        pub const LV_SYMBOL_IMAGE: &'static [u8; 4usize] = b"\xEF\x80\xBE\0";
        pub const LV_SYMBOL_EDIT: &'static [u8; 4usize] = b"\xEF\x8C\x84\0";
        pub const LV_SYMBOL_PREV: &'static [u8; 4usize] = b"\xEF\x81\x88\0";
        pub const LV_SYMBOL_PLAY: &'static [u8; 4usize] = b"\xEF\x81\x8B\0";
        pub const LV_SYMBOL_PAUSE: &'static [u8; 4usize] = b"\xEF\x81\x8C\0";
        pub const LV_SYMBOL_STOP: &'static [u8; 4usize] = b"\xEF\x81\x8D\0";
        pub const LV_SYMBOL_NEXT: &'static [u8; 4usize] = b"\xEF\x81\x91\0";
        pub const LV_SYMBOL_EJECT: &'static [u8; 4usize] = b"\xEF\x81\x92\0";
        pub const LV_SYMBOL_LEFT: &'static [u8; 4usize] = b"\xEF\x81\x93\0";
        pub const LV_SYMBOL_RIGHT: &'static [u8; 4usize] = b"\xEF\x81\x94\0";
        pub const LV_SYMBOL_PLUS: &'static [u8; 4usize] = b"\xEF\x81\xA7\0";
        pub const LV_SYMBOL_MINUS: &'static [u8; 4usize] = b"\xEF\x81\xA8\0";
        pub const LV_SYMBOL_EYE_OPEN: &'static [u8; 4usize] =
            b"\xEF\x81\xAE\0";
        pub const LV_SYMBOL_EYE_CLOSE: &'static [u8; 4usize] =
            b"\xEF\x81\xB0\0";
        pub const LV_SYMBOL_WARNING: &'static [u8; 4usize] =
            b"\xEF\x81\xB1\0";
        pub const LV_SYMBOL_SHUFFLE: &'static [u8; 4usize] =
            b"\xEF\x81\xB4\0";
        pub const LV_SYMBOL_UP: &'static [u8; 4usize] = b"\xEF\x81\xB7\0";
        pub const LV_SYMBOL_DOWN: &'static [u8; 4usize] = b"\xEF\x81\xB8\0";
        pub const LV_SYMBOL_LOOP: &'static [u8; 4usize] = b"\xEF\x81\xB9\0";
        pub const LV_SYMBOL_DIRECTORY: &'static [u8; 4usize] =
            b"\xEF\x81\xBB\0";
        pub const LV_SYMBOL_UPLOAD: &'static [u8; 4usize] = b"\xEF\x82\x93\0";
        pub const LV_SYMBOL_CALL: &'static [u8; 4usize] = b"\xEF\x82\x95\0";
        pub const LV_SYMBOL_CUT: &'static [u8; 4usize] = b"\xEF\x83\x84\0";
        pub const LV_SYMBOL_COPY: &'static [u8; 4usize] = b"\xEF\x83\x85\0";
        pub const LV_SYMBOL_SAVE: &'static [u8; 4usize] = b"\xEF\x83\x87\0";
        pub const LV_SYMBOL_CHARGE: &'static [u8; 4usize] = b"\xEF\x83\xA7\0";
        pub const LV_SYMBOL_PASTE: &'static [u8; 4usize] = b"\xEF\x83\xAA\0";
        pub const LV_SYMBOL_BELL: &'static [u8; 4usize] = b"\xEF\x83\xB3\0";
        pub const LV_SYMBOL_KEYBOARD: &'static [u8; 4usize] =
            b"\xEF\x84\x9C\0";
        pub const LV_SYMBOL_GPS: &'static [u8; 4usize] = b"\xEF\x84\xA4\0";
        pub const LV_SYMBOL_FILE: &'static [u8; 4usize] = b"\xEF\x85\x9B\0";
        pub const LV_SYMBOL_WIFI: &'static [u8; 4usize] = b"\xEF\x87\xAB\0";
        pub const LV_SYMBOL_BATTERY_FULL: &'static [u8; 4usize] =
            b"\xEF\x89\x80\0";
        pub const LV_SYMBOL_BATTERY_3: &'static [u8; 4usize] =
            b"\xEF\x89\x81\0";
        pub const LV_SYMBOL_BATTERY_2: &'static [u8; 4usize] =
            b"\xEF\x89\x82\0";
        pub const LV_SYMBOL_BATTERY_1: &'static [u8; 4usize] =
            b"\xEF\x89\x83\0";
        pub const LV_SYMBOL_BATTERY_EMPTY: &'static [u8; 4usize] =
            b"\xEF\x89\x84\0";
        pub const LV_SYMBOL_USB: &'static [u8; 4usize] = b"\xEF\x8A\x87\0";
        pub const LV_SYMBOL_BLUETOOTH: &'static [u8; 4usize] =
            b"\xEF\x8A\x93\0";
        pub const LV_SYMBOL_TRASH: &'static [u8; 4usize] = b"\xEF\x8B\xAD\0";
        pub const LV_SYMBOL_BACKSPACE: &'static [u8; 4usize] =
            b"\xEF\x95\x9A\0";
        pub const LV_SYMBOL_SD_CARD: &'static [u8; 4usize] =
            b"\xEF\x9F\x82\0";
        pub const LV_SYMBOL_NEW_LINE: &'static [u8; 4usize] =
            b"\xEF\xA2\xA2\0";
        pub const LV_SYMBOL_DUMMY: &'static [u8; 4usize] = b"\xEF\xA3\xBF\0";
        pub const LV_FONT_WIDTH_FRACT_DIGIT: u32 = 4;
        pub const LV_FONT_KERN_POSITIVE: u32 = 0;
        pub const LV_FONT_KERN_NEGATIVE: u32 = 1;
        pub const LV_OPA_MIN: u32 = 16;
        pub const LV_OPA_MAX: u32 = 251;
        pub const LV_COLOR_SIZE: u32 = 16;
        pub const LV_STYLE_DEGUG_SENTINEL_VALUE: u32 = 305419896;
        pub const LV_LOG_LEVEL_TRACE: u32 = 0;
        pub const LV_LOG_LEVEL_INFO: u32 = 1;
        pub const LV_LOG_LEVEL_WARN: u32 = 2;
        pub const LV_LOG_LEVEL_ERROR: u32 = 3;
        pub const LV_LOG_LEVEL_NONE: u32 = 4;
        pub const LV_BIDI_LRO: &'static [u8; 4usize] = b"\xE2\x80\xAD\0";
        pub const LV_BIDI_RLO: &'static [u8; 4usize] = b"\xE2\x80\xAE\0";
        pub const LV_INV_BUF_SIZE: u32 = 32;
        pub const LV_MAX_ANCESTOR_NUM: u32 = 8;
        pub const LV_EXT_CLICK_AREA_OFF: u32 = 0;
        pub const LV_EXT_CLICK_AREA_TINY: u32 = 1;
        pub const LV_EXT_CLICK_AREA_FULL: u32 = 2;
        pub type lv_coord_t = i16;
        pub type lv_anim_user_data_t = *mut ::cty::c_void;
        pub type lv_group_user_data_t = *mut ::cty::c_void;
        pub type lv_img_decoder_user_data_t = *mut ::cty::c_void;
        pub type lv_disp_drv_user_data_t = *mut ::cty::c_void;
        pub type lv_indev_drv_user_data_t = *mut ::cty::c_void;
        pub type lv_font_user_data_t = *mut ::cty::c_void;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        #[doc = " Describes the properties of a glyph."]
        #[repr(C)]
        pub struct lv_font_glyph_dsc_t {
            #[doc =
              "< The glyph needs this space. Draw the next glyph after this width. 8 bit integer, 4 bit fractional"]
            pub adv_w: u16,
            #[doc = "< Width of the glyph's bounding box"]
            pub box_w: u8,
            #[doc = "< Height of the glyph's bounding box"]
            pub box_h: u8,
            #[doc = "< x offset of the bounding box"]
            pub ofs_x: i8,
            #[doc = "< y offset of the bounding box"]
            pub ofs_y: i8,
            #[doc = "< Bit-per-pixel: 1, 2, 4, 8"]
            pub bpp: u8,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_font_glyph_dsc_t {
            #[inline]
            fn default() -> lv_font_glyph_dsc_t {
                lv_font_glyph_dsc_t{adv_w:
                                        ::core::default::Default::default(),
                                    box_w:
                                        ::core::default::Default::default(),
                                    box_h:
                                        ::core::default::Default::default(),
                                    ofs_x:
                                        ::core::default::Default::default(),
                                    ofs_y:
                                        ::core::default::Default::default(),
                                    bpp: ::core::default::Default::default(),}
            }
        }
        pub const LV_FONT_SUBPX_NONE: _bindgen_ty_2 = 0;
        pub const LV_FONT_SUBPX_HOR: _bindgen_ty_2 = 1;
        pub const LV_FONT_SUBPX_VER: _bindgen_ty_2 = 2;
        pub const LV_FONT_SUBPX_BOTH: _bindgen_ty_2 = 3;
        #[doc =
          " The bitmaps might be upscaled by 3 to achieve subpixel rendering."]
        pub type _bindgen_ty_2 = u8;
        pub type lv_font_subpx_t = u8;
        #[doc = " Describe the properties of a font"]
        #[repr(C)]
        pub struct _lv_font_struct {
            #[doc = " Get a glyph's  descriptor from a font"]
            pub get_glyph_dsc: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                               *const _lv_font_struct,
                                                                           arg2:
                                                                               *mut lv_font_glyph_dsc_t,
                                                                           letter:
                                                                               u32,
                                                                           letter_next:
                                                                               u32)
                                                          -> bool>,
            #[doc = " Get a glyph's bitmap from a font"]
            pub get_glyph_bitmap: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *const _lv_font_struct,
                                                                              arg2:
                                                                                  u32)
                                                             -> *const u8>,
            #[doc = "< The real line height where any text fits"]
            pub line_height: u8,
            #[doc = "< Base line measured from the top of the line_height"]
            pub base_line: u8,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            #[doc =
              "< Store implementation specific or run_time data or caching here"]
            pub dsc: *mut ::cty::c_void,
            #[doc = "< Custom user data for font."]
            pub user_data: lv_font_user_data_t,
        }
        impl Default for _lv_font_struct {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_font_struct {
            #[inline]
            pub fn subpx(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_subpx(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(subpx: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 2u8,
                                            {
                                                let subpx: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(subpx)
                                                    };
                                                subpx as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_font_t = _lv_font_struct;
        #[doc = " Return with the bitmap of a font."]
        #[doc = " - __`font_p`__: pointer to a font"]
        #[doc = " - __`letter`__: an UNICODE character code"]
        #[doc = " Return:  pointer to the bitmap of the letter"]
        pub fn font_get_glyph_bitmap(font_p: *const lv_font_t, letter: u32)
         -> LvglResult<*const u8> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Return with the bitmap of a font."]
                #[doc = " - __`font_p`__: pointer to a font"]
                #[doc = " - __`letter`__: an UNICODE character code"]
                #[doc = " Return:  pointer to the bitmap of the letter"]
                pub fn lv_font_get_glyph_bitmap(font_p: *const lv_font_t,
                                                letter: u32)
                -> *const u8;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_font_get_glyph_bitmap(font_p as *const lv_font_t,
                                             letter as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the descriptor of a glyph"]
        #[doc = " - __`font_p`__: pointer to font"]
        #[doc = " - __`dsc_out`__: store the result descriptor here"]
        #[doc = " - __`letter`__: an UNICODE letter code"]
        #[doc =
          " Return: true: descriptor is successfully loaded into `dsc_out`."]
        #[doc =
          "         false: the letter was not found, no data is loaded to `dsc_out`"]
        pub fn font_get_glyph_dsc(font_p: *const lv_font_t,
                                  dsc_out: *mut lv_font_glyph_dsc_t,
                                  letter: u32, letter_next: u32)
         -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the descriptor of a glyph"]
                #[doc = " - __`font_p`__: pointer to font"]
                #[doc = " - __`dsc_out`__: store the result descriptor here"]
                #[doc = " - __`letter`__: an UNICODE letter code"]
                #[doc =
                  " Return: true: descriptor is successfully loaded into `dsc_out`."]
                #[doc =
                  "         false: the letter was not found, no data is loaded to `dsc_out`"]
                pub fn lv_font_get_glyph_dsc(font_p: *const lv_font_t,
                                             dsc_out:
                                                 *mut lv_font_glyph_dsc_t,
                                             letter: u32, letter_next: u32)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_font_get_glyph_dsc(font_p as *const lv_font_t,
                                          dsc_out as *mut lv_font_glyph_dsc_t,
                                          letter as u32, letter_next as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the width of a glyph with kerning"]
        #[doc = " - __`font`__: pointer to a font"]
        #[doc = " - __`letter`__: an UNICODE letter"]
        #[doc =
          " - __`letter_next`__: the next letter after `letter`. Used for kerning"]
        #[doc = " Return: the width of the glyph"]
        pub fn font_get_glyph_width(font: *const lv_font_t, letter: u32,
                                    letter_next: u32) -> LvglResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the width of a glyph with kerning"]
                #[doc = " - __`font`__: pointer to a font"]
                #[doc = " - __`letter`__: an UNICODE letter"]
                #[doc =
                  " - __`letter_next`__: the next letter after `letter`. Used for kerning"]
                #[doc = " Return: the width of the glyph"]
                pub fn lv_font_get_glyph_width(font: *const lv_font_t,
                                               letter: u32, letter_next: u32)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_font_get_glyph_width(font as *const lv_font_t,
                                            letter as u32,
                                            letter_next as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get the line height of a font. All characters fit into this height"]
        #[doc = " - __`font_p`__: pointer to a font"]
        #[doc = " Return: the height of a font"]
        pub fn font_get_line_height(font_p: *const lv_font_t)
         -> LvglResult<u8> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the line height of a font. All characters fit into this height"]
                #[doc = " - __`font_p`__: pointer to a font"]
                #[doc = " Return: the height of a font"]
                pub fn lv_font_get_line_height(font_p: *const lv_font_t)
                -> u8;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_font_get_line_height(font_p as *const lv_font_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        extern "C" {
            pub static mut lv_font_roboto_28: lv_font_t;
        }
        pub const LV_OPA_TRANSP: _bindgen_ty_3 = 0;
        pub const LV_OPA_0: _bindgen_ty_3 = 0;
        pub const LV_OPA_10: _bindgen_ty_3 = 25;
        pub const LV_OPA_20: _bindgen_ty_3 = 51;
        pub const LV_OPA_30: _bindgen_ty_3 = 76;
        pub const LV_OPA_40: _bindgen_ty_3 = 102;
        pub const LV_OPA_50: _bindgen_ty_3 = 127;
        pub const LV_OPA_60: _bindgen_ty_3 = 153;
        pub const LV_OPA_70: _bindgen_ty_3 = 178;
        pub const LV_OPA_80: _bindgen_ty_3 = 204;
        pub const LV_OPA_90: _bindgen_ty_3 = 229;
        pub const LV_OPA_100: _bindgen_ty_3 = 255;
        pub const LV_OPA_COVER: _bindgen_ty_3 = 255;
        #[doc = " Opacity percentages."]
        pub type _bindgen_ty_3 = u8;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_color1_t {
            pub ch: __BindgenUnionField<lv_color1_t__bindgen_ty_1>,
            pub full: __BindgenUnionField<u8>,
            pub bindgen_union_field: u8,
        }
        #[repr(C, packed)]
        pub struct lv_color1_t__bindgen_ty_1 {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_color1_t__bindgen_ty_1 {
            #[inline]
            fn default() -> lv_color1_t__bindgen_ty_1 {
                lv_color1_t__bindgen_ty_1{_bitfield_1:
                                              ::core::default::Default::default(),}
            }
        }
        impl lv_color1_t__bindgen_ty_1 {
            #[inline]
            pub fn blue(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_blue(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn green(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_green(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn red(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_red(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(blue: u8, green: u8, red: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let blue: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(blue)
                                                    };
                                                blue as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let green: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(green)
                                                    };
                                                green as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let red: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(red)
                                                    };
                                                red as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_color1_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[repr(C)]
        pub struct lv_color8_t {
            pub ch: __BindgenUnionField<lv_color8_t__bindgen_ty_1>,
            pub full: __BindgenUnionField<u8>,
            pub bindgen_union_field: u8,
        }
        #[repr(C, packed)]
        pub struct lv_color8_t__bindgen_ty_1 {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_color8_t__bindgen_ty_1 {
            #[inline]
            fn default() -> lv_color8_t__bindgen_ty_1 {
                lv_color8_t__bindgen_ty_1{_bitfield_1:
                                              ::core::default::Default::default(),}
            }
        }
        impl lv_color8_t__bindgen_ty_1 {
            #[inline]
            pub fn blue(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_blue(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn green(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_green(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn red(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_red(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(5usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(blue: u8, green: u8, red: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 2u8,
                                            {
                                                let blue: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(blue)
                                                    };
                                                blue as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 3u8,
                                            {
                                                let green: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(green)
                                                    };
                                                green as u64
                                            });
                __bindgen_bitfield_unit.set(5usize, 3u8,
                                            {
                                                let red: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(red)
                                                    };
                                                red as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_color8_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[repr(C)]
        pub struct lv_color16_t {
            pub ch: __BindgenUnionField<lv_color16_t__bindgen_ty_1>,
            pub full: __BindgenUnionField<u16>,
            pub bindgen_union_field: u16,
        }
        #[repr(C)]
        #[repr(align (2))]
        pub struct lv_color16_t__bindgen_ty_1 {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_color16_t__bindgen_ty_1 {
            #[inline]
            fn default() -> lv_color16_t__bindgen_ty_1 {
                lv_color16_t__bindgen_ty_1{_bitfield_1:
                                               ::core::default::Default::default(),}
            }
        }
        impl lv_color16_t__bindgen_ty_1 {
            #[inline]
            pub fn green_h(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_h(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn red(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_red(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn blue(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_blue(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn green_l(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_l(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(green_h: u16, red: u16, blue: u16,
                                  green_l: u16)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 3u8,
                                            {
                                                let green_h: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_h)
                                                    };
                                                green_h as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 5u8,
                                            {
                                                let red: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(red)
                                                    };
                                                red as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 5u8,
                                            {
                                                let blue: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(blue)
                                                    };
                                                blue as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 3u8,
                                            {
                                                let green_l: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_l)
                                                    };
                                                green_l as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_color16_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[repr(C)]
        pub struct lv_color32_t {
            pub ch: __BindgenUnionField<lv_color32_t__bindgen_ty_1>,
            pub full: __BindgenUnionField<u32>,
            pub bindgen_union_field: u32,
        }
        #[repr(C)]
        pub struct lv_color32_t__bindgen_ty_1 {
            pub blue: u8,
            pub green: u8,
            pub red: u8,
            pub alpha: u8,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_color32_t__bindgen_ty_1 {
            #[inline]
            fn default() -> lv_color32_t__bindgen_ty_1 {
                lv_color32_t__bindgen_ty_1{blue:
                                               ::core::default::Default::default(),
                                           green:
                                               ::core::default::Default::default(),
                                           red:
                                               ::core::default::Default::default(),
                                           alpha:
                                               ::core::default::Default::default(),}
            }
        }
        impl Default for lv_color32_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_color_int_t = u16;
        pub type lv_color_t = lv_color16_t;
        pub type lv_opa_t = u8;
        #[repr(C)]
        pub struct lv_color_hsv_t {
            pub h: u16,
            pub s: u8,
            pub v: u8,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_color_hsv_t {
            #[inline]
            fn default() -> lv_color_hsv_t {
                lv_color_hsv_t{h: ::core::default::Default::default(),
                               s: ::core::default::Default::default(),
                               v: ::core::default::Default::default(),}
            }
        }
        #[doc = " GLOBAL PROTOTYPES"]
        pub fn color_to1(color: lv_color_t) -> LvglResult<u8> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " GLOBAL PROTOTYPES"]
                pub fn lv_color_to1(color: lv_color_t)
                -> u8;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_color_to1(color as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn color_to8(color: lv_color_t) -> LvglResult<u8> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_color_to8(color: lv_color_t)
                -> u8;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_color_to8(color as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn color_to16(color: lv_color_t) -> LvglResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_color_to16(color: lv_color_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_color_to16(color as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn color_to32(color: lv_color_t) -> LvglResult<u32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_color_to32(color: lv_color_t)
                -> u32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_color_to32(color as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn color_mix(c1: lv_color_t, c2: lv_color_t, mix: u8)
         -> LvglResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_color_mix(c1: lv_color_t, c2: lv_color_t, mix: u8)
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_color_mix(c1 as lv_color_t, c2 as lv_color_t,
                                 mix as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the brightness of a color"]
        #[doc = " - __`color`__: a color"]
        #[doc = " Return: the brightness [0..255]"]
        pub fn color_brightness(color: lv_color_t) -> LvglResult<u8> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the brightness of a color"]
                #[doc = " - __`color`__: a color"]
                #[doc = " Return: the brightness [0..255]"]
                pub fn lv_color_brightness(color: lv_color_t)
                -> u8;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_color_brightness(color as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn color_make(r: u8, g: u8, b: u8) -> LvglResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_color_make(r: u8, g: u8, b: u8)
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_color_make(r as u8, g as u8, b as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn color_hex(c: u32) -> LvglResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_color_hex(c: u32)
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_color_hex(c as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn color_hex3(c: u32) -> LvglResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_color_hex3(c: u32)
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_color_hex3(c as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Convert a HSV color to RGB"]
        #[doc = " - __`h`__: hue [0..359]"]
        #[doc = " - __`s`__: saturation [0..100]"]
        #[doc = " - __`v`__: value [0..100]"]
        #[doc =
          " Return: the given RGB color in RGB (with LV_COLOR_DEPTH depth)"]
        pub fn color_hsv_to_rgb(h: u16, s: u8, v: u8)
         -> LvglResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Convert a HSV color to RGB"]
                #[doc = " - __`h`__: hue [0..359]"]
                #[doc = " - __`s`__: saturation [0..100]"]
                #[doc = " - __`v`__: value [0..100]"]
                #[doc =
                  " Return: the given RGB color in RGB (with LV_COLOR_DEPTH depth)"]
                pub fn lv_color_hsv_to_rgb(h: u16, s: u8, v: u8)
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_color_hsv_to_rgb(h as u16, s as u8, v as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Convert a 32-bit RGB color to HSV"]
        #[doc = " - __`r8`__: 8-bit red"]
        #[doc = " - __`g8`__: 8-bit green"]
        #[doc = " - __`b8`__: 8-bit blue"]
        #[doc = " Return: the given RGB color in HSV"]
        pub fn color_rgb_to_hsv(r8: u8, g8: u8, b8: u8)
         -> LvglResult<lv_color_hsv_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Convert a 32-bit RGB color to HSV"]
                #[doc = " - __`r8`__: 8-bit red"]
                #[doc = " - __`g8`__: 8-bit green"]
                #[doc = " - __`b8`__: 8-bit blue"]
                #[doc = " Return: the given RGB color in HSV"]
                pub fn lv_color_rgb_to_hsv(r8: u8, g8: u8, b8: u8)
                -> lv_color_hsv_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_color_rgb_to_hsv(r8 as u8, g8 as u8, b8 as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Convert a color to HSV"]
        #[doc = " - __`color`__: color"]
        #[doc = " Return: the given color in HSV"]
        pub fn color_to_hsv(color: lv_color_t) -> LvglResult<lv_color_hsv_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Convert a color to HSV"]
                #[doc = " - __`color`__: color"]
                #[doc = " Return: the given color in HSV"]
                pub fn lv_color_to_hsv(color: lv_color_t)
                -> lv_color_hsv_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_color_to_hsv(color as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Represents a point on the screen."]
        #[repr(C)]
        pub struct lv_point_t {
            pub x: lv_coord_t,
            pub y: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_point_t {
            #[inline]
            fn default() -> lv_point_t {
                lv_point_t{x: ::core::default::Default::default(),
                           y: ::core::default::Default::default(),}
            }
        }
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        #[doc = " Initialize an area"]
        #[doc = " - __`area_p`__: pointer to an area"]
        #[doc = " - __`x1`__: left coordinate of the area"]
        #[doc = " - __`y1`__: top coordinate of the area"]
        #[doc = " - __`x2`__: right coordinate of the area"]
        #[doc = " - __`y2`__: bottom coordinate of the area"]
        pub fn area_set(area_p: *mut lv_area_t, x1: lv_coord_t,
                        y1: lv_coord_t, x2: lv_coord_t, y2: lv_coord_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Initialize an area"]
                #[doc = " - __`area_p`__: pointer to an area"]
                #[doc = " - __`x1`__: left coordinate of the area"]
                #[doc = " - __`y1`__: top coordinate of the area"]
                #[doc = " - __`x2`__: right coordinate of the area"]
                #[doc = " - __`y2`__: bottom coordinate of the area"]
                pub fn lv_area_set(area_p: *mut lv_area_t, x1: lv_coord_t,
                                   y1: lv_coord_t, x2: lv_coord_t,
                                   y2: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_area_set(area_p as *mut lv_area_t, x1 as lv_coord_t,
                            y1 as lv_coord_t, x2 as lv_coord_t,
                            y2 as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Copy an area"]
        #[doc = " - __`dest`__: pointer to the destination area"]
        #[doc = " - __`src`__: pointer to the source area"]
        pub fn area_copy(dest: *mut lv_area_t, src: *const lv_area_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Copy an area"]
                #[doc = " - __`dest`__: pointer to the destination area"]
                #[doc = " - __`src`__: pointer to the source area"]
                pub fn lv_area_copy(dest: *mut lv_area_t,
                                    src: *const lv_area_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_area_copy(dest as *mut lv_area_t, src as *const lv_area_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the width of an area"]
        #[doc = " - __`area_p`__: pointer to an area"]
        #[doc = " Return: the width of the area (if x1 == x2 -> width = 1)"]
        pub fn area_get_width(area_p: *const lv_area_t)
         -> LvglResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the width of an area"]
                #[doc = " - __`area_p`__: pointer to an area"]
                #[doc =
                  " Return: the width of the area (if x1 == x2 -> width = 1)"]
                pub fn lv_area_get_width(area_p: *const lv_area_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_area_get_width(area_p as *const lv_area_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the height of an area"]
        #[doc = " - __`area_p`__: pointer to an area"]
        #[doc = " Return: the height of the area (if y1 == y2 -> height = 1)"]
        pub fn area_get_height(area_p: *const lv_area_t)
         -> LvglResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the height of an area"]
                #[doc = " - __`area_p`__: pointer to an area"]
                #[doc =
                  " Return: the height of the area (if y1 == y2 -> height = 1)"]
                pub fn lv_area_get_height(area_p: *const lv_area_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_area_get_height(area_p as *const lv_area_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set the width of an area"]
        #[doc = " - __`area_p`__: pointer to an area"]
        #[doc =
          " - __`w`__: the new width of the area (w == 1 makes x1 == x2)"]
        pub fn area_set_width(area_p: *mut lv_area_t, w: lv_coord_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the width of an area"]
                #[doc = " - __`area_p`__: pointer to an area"]
                #[doc =
                  " - __`w`__: the new width of the area (w == 1 makes x1 == x2)"]
                pub fn lv_area_set_width(area_p: *mut lv_area_t,
                                         w: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_area_set_width(area_p as *mut lv_area_t, w as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the height of an area"]
        #[doc = " - __`area_p`__: pointer to an area"]
        #[doc =
          " - __`h`__: the new height of the area (h == 1 makes y1 == y2)"]
        pub fn area_set_height(area_p: *mut lv_area_t, h: lv_coord_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the height of an area"]
                #[doc = " - __`area_p`__: pointer to an area"]
                #[doc =
                  " - __`h`__: the new height of the area (h == 1 makes y1 == y2)"]
                pub fn lv_area_set_height(area_p: *mut lv_area_t,
                                          h: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_area_set_height(area_p as *mut lv_area_t, h as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the position of an area (width and height will be kept)"]
        #[doc = " - __`area_p`__: pointer to an area"]
        #[doc = " - __`x`__: the new x coordinate of the area"]
        #[doc = " - __`y`__: the new y coordinate of the area"]
        pub fn area_set_pos(area_p: *mut lv_area_t, x: lv_coord_t,
                            y: lv_coord_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the position of an area (width and height will be kept)"]
                #[doc = " - __`area_p`__: pointer to an area"]
                #[doc = " - __`x`__: the new x coordinate of the area"]
                #[doc = " - __`y`__: the new y coordinate of the area"]
                pub fn lv_area_set_pos(area_p: *mut lv_area_t, x: lv_coord_t,
                                       y: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_area_set_pos(area_p as *mut lv_area_t, x as lv_coord_t,
                                y as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Return with area of an area (x * y)"]
        #[doc = " - __`area_p`__: pointer to an area"]
        #[doc = " Return: size of area"]
        pub fn area_get_size(area_p: *const lv_area_t) -> LvglResult<u32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Return with area of an area (x * y)"]
                #[doc = " - __`area_p`__: pointer to an area"]
                #[doc = " Return: size of area"]
                pub fn lv_area_get_size(area_p: *const lv_area_t)
                -> u32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_area_get_size(area_p as *const lv_area_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the common parts of two areas"]
        #[doc =
          " - __`res_p`__: pointer to an area, the result will be stored her"]
        #[doc = " - __`a1_p`__: pointer to the first area"]
        #[doc = " - __`a2_p`__: pointer to the second area"]
        #[doc =
          " Return: false: the two area has NO common parts, res_p is invalid"]
        pub fn area_intersect(res_p: *mut lv_area_t, a1_p: *const lv_area_t,
                              a2_p: *const lv_area_t) -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the common parts of two areas"]
                #[doc =
                  " - __`res_p`__: pointer to an area, the result will be stored her"]
                #[doc = " - __`a1_p`__: pointer to the first area"]
                #[doc = " - __`a2_p`__: pointer to the second area"]
                #[doc =
                  " Return: false: the two area has NO common parts, res_p is invalid"]
                pub fn lv_area_intersect(res_p: *mut lv_area_t,
                                         a1_p: *const lv_area_t,
                                         a2_p: *const lv_area_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_area_intersect(res_p as *mut lv_area_t,
                                      a1_p as *const lv_area_t,
                                      a2_p as *const lv_area_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Join two areas into a third which involves the other two"]
        #[doc =
          " - __`res_p`__: pointer to an area, the result will be stored here"]
        #[doc = " - __`a1_p`__: pointer to the first area"]
        #[doc = " - __`a2_p`__: pointer to the second area"]
        pub fn area_join(a_res_p: *mut lv_area_t, a1_p: *const lv_area_t,
                         a2_p: *const lv_area_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Join two areas into a third which involves the other two"]
                #[doc =
                  " - __`res_p`__: pointer to an area, the result will be stored here"]
                #[doc = " - __`a1_p`__: pointer to the first area"]
                #[doc = " - __`a2_p`__: pointer to the second area"]
                pub fn lv_area_join(a_res_p: *mut lv_area_t,
                                    a1_p: *const lv_area_t,
                                    a2_p: *const lv_area_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_area_join(a_res_p as *mut lv_area_t,
                             a1_p as *const lv_area_t,
                             a2_p as *const lv_area_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Check if a point is on an area"]
        #[doc = " - __`a_p`__: pointer to an area"]
        #[doc = " - __`p_p`__: pointer to a point"]
        #[doc = " Return: false:the point is out of the area"]
        pub fn area_is_point_on(a_p: *const lv_area_t, p_p: *const lv_point_t)
         -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Check if a point is on an area"]
                #[doc = " - __`a_p`__: pointer to an area"]
                #[doc = " - __`p_p`__: pointer to a point"]
                #[doc = " Return: false:the point is out of the area"]
                pub fn lv_area_is_point_on(a_p: *const lv_area_t,
                                           p_p: *const lv_point_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_area_is_point_on(a_p as *const lv_area_t,
                                        p_p as *const lv_point_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Check if two area has common parts"]
        #[doc = " - __`a1_p`__: pointer to an area."]
        #[doc = " - __`a2_p`__: pointer to an other area"]
        #[doc = " Return: false: a1_p and a2_p has no common parts"]
        pub fn area_is_on(a1_p: *const lv_area_t, a2_p: *const lv_area_t)
         -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Check if two area has common parts"]
                #[doc = " - __`a1_p`__: pointer to an area."]
                #[doc = " - __`a2_p`__: pointer to an other area"]
                #[doc = " Return: false: a1_p and a2_p has no common parts"]
                pub fn lv_area_is_on(a1_p: *const lv_area_t,
                                     a2_p: *const lv_area_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_area_is_on(a1_p as *const lv_area_t,
                                  a2_p as *const lv_area_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Check if an area is fully on an other"]
        #[doc =
          " - __`ain_p`__: pointer to an area which could be on aholder_p"]
        #[doc =
          " - __`aholder`__: pointer to an area which could involve ain_p"]
        #[doc = " @return"]
        pub fn area_is_in(ain_p: *const lv_area_t,
                          aholder_p: *const lv_area_t) -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Check if an area is fully on an other"]
                #[doc =
                  " - __`ain_p`__: pointer to an area which could be on aholder_p"]
                #[doc =
                  " - __`aholder`__: pointer to an area which could involve ain_p"]
                #[doc = " @return"]
                pub fn lv_area_is_in(ain_p: *const lv_area_t,
                                     aholder_p: *const lv_area_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_area_is_in(ain_p as *const lv_area_t,
                                  aholder_p as *const lv_area_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Increment or decrement an area's size by a single amount"]
        #[doc = " - __`a_p`__: pointer to an area to grow"]
        #[doc =
          " - __`amount`__: amount to increment the area, or negative to decrement"]
        pub fn area_increment(a_p: *mut lv_area_t, amount: lv_coord_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Increment or decrement an area's size by a single amount"]
                #[doc = " - __`a_p`__: pointer to an area to grow"]
                #[doc =
                  " - __`amount`__: amount to increment the area, or negative to decrement"]
                pub fn lv_area_increment(a_p: *mut lv_area_t,
                                         amount: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_area_increment(a_p as *mut lv_area_t,
                                  amount as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub const LV_ANIM_OFF: _bindgen_ty_4 = 0;
        pub const LV_ANIM_ON: _bindgen_ty_4 = 1;
        #[doc =
          " Can be used to indicate if animations are enabled or disabled in a case"]
        pub type _bindgen_ty_4 = u8;
        pub type lv_anim_enable_t = u8;
        #[doc = " Type of the animated value"]
        pub type lv_anim_value_t = lv_coord_t;
        #[doc = " Generic prototype of \"animator\" functions."]
        #[doc = " First parameter is the variable to animate."]
        #[doc = " Second parameter is the value to set."]
        #[doc = " Compatible with `lv_xxx_set_yyy(obj, value)` functions"]
        #[doc =
          " The `x` in `_xcb_t` means its not a fully generic prototype because"]
        #[doc = " it doesn't receive `lv_anim_t *` as its first argument"]
        pub type lv_anim_exec_xcb_t
            =
            ::core::option::Option<unsafe extern "C" fn(arg1:
                                                            *mut ::cty::c_void,
                                                        arg2:
                                                            lv_anim_value_t)>;
        #[doc =
          " Same as `lv_anim_exec_xcb_t` but receives `lv_anim_t *` as the first parameter."]
        #[doc =
          " It's more consistent but less convenient. Might be used by binding generator functions."]
        pub type lv_anim_custom_exec_cb_t
            =
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_anim_t,
                                                        arg2:
                                                            lv_anim_value_t)>;
        #[doc = " Get the current value during an animation"]
        pub type lv_anim_path_cb_t
            =
            ::core::option::Option<unsafe extern "C" fn(arg1:
                                                            *const _lv_anim_t)
                                       -> lv_anim_value_t>;
        #[doc = " Callback to call when the animation is ready"]
        pub type lv_anim_ready_cb_t
            =
            ::core::option::Option<unsafe extern "C" fn(arg1:
                                                            *mut _lv_anim_t)>;
        #[doc = " Describes an animation"]
        #[repr(C)]
        pub struct _lv_anim_t {
            #[doc = "<Variable to animate"]
            pub var: *mut ::cty::c_void,
            #[doc = "< Function to execute to animate"]
            pub exec_cb: lv_anim_exec_xcb_t,
            #[doc = "< Function to get the steps of animations"]
            pub path_cb: lv_anim_path_cb_t,
            #[doc = "< Call it when the animation is ready"]
            pub ready_cb: lv_anim_ready_cb_t,
            #[doc = "< Start value"]
            pub start: i32,
            #[doc = "< End value"]
            pub end: i32,
            #[doc = "< Animation time in ms"]
            pub time: u16,
            #[doc =
              "< Current time in animation. Set to negative to make delay."]
            pub act_time: i16,
            #[doc = "< Wait before play back"]
            pub playback_pause: u16,
            #[doc = "< Wait before repeat"]
            pub repeat_pause: u16,
            #[doc = "< Custom user data"]
            pub user_data: lv_anim_user_data_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for _lv_anim_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_anim_t {
            #[inline]
            pub fn playback(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_playback(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn repeat(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_repeat(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn playback_now(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_playback_now(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_run(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_run(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(playback: u8, repeat: u8, playback_now: u8,
                                  has_run: u32)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let playback: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(playback)
                                                    };
                                                playback as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let repeat: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(repeat)
                                                    };
                                                repeat as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let playback_now: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(playback_now)
                                                    };
                                                playback_now as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let has_run: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_run)
                                                    };
                                                has_run as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_anim_t = _lv_anim_t;
        #[doc = " Init. the animation module"]
        pub fn anim_core_init() -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Init. the animation module"]
                pub fn lv_anim_core_init();
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_anim_core_init();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Initialize an animation variable."]
        #[doc = " E.g.:"]
        #[doc = " lv_anim_t a;"]
        #[doc = " lv_anim_init(&a);"]
        #[doc = " lv_anim_set_...(&a);"]
        #[doc = " lv_anim_create(&a);"]
        #[doc =
          " - __`a`__: pointer to an `lv_anim_t` variable to initialize"]
        pub fn anim_init(a: *mut lv_anim_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Initialize an animation variable."]
                #[doc = " E.g.:"]
                #[doc = " lv_anim_t a;"]
                #[doc = " lv_anim_init(&a);"]
                #[doc = " lv_anim_set_...(&a);"]
                #[doc = " lv_anim_create(&a);"]
                #[doc =
                  " - __`a`__: pointer to an `lv_anim_t` variable to initialize"]
                pub fn lv_anim_init(a: *mut lv_anim_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_anim_init(a as *mut lv_anim_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set a variable to animate function to execute on `var`"]
        #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
        #[doc = " - __`var`__: pointer to a variable to animate"]
        #[doc = " - __`exec_cb`__: a function to execute."]
        #[doc = "                LittelvGL's built-in functions can be used."]
        #[doc = "                E.g. lv_obj_set_x"]
        pub fn anim_set_exec_cb(a: *mut lv_anim_t, var: Ptr,
                                exec_cb: lv_anim_exec_xcb_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set a variable to animate function to execute on `var`"]
                #[doc =
                  " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
                #[doc = " - __`var`__: pointer to a variable to animate"]
                #[doc = " - __`exec_cb`__: a function to execute."]
                #[doc =
                  "                LittelvGL's built-in functions can be used."]
                #[doc = "                E.g. lv_obj_set_x"]
                pub fn lv_anim_set_exec_cb(a: *mut lv_anim_t,
                                           var: *mut ::cty::c_void,
                                           exec_cb: lv_anim_exec_xcb_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_anim_set_exec_cb(a as *mut lv_anim_t,
                                    var as *mut ::cty::c_void,
                                    exec_cb as lv_anim_exec_xcb_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the duration and delay of an animation"]
        #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
        #[doc =
          " - __`duration`__: duration of the animation in milliseconds"]
        #[doc = " - __`delay`__: delay before the animation in milliseconds"]
        pub fn anim_set_time(a: *mut lv_anim_t, duration: u16, delay: i16)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the duration and delay of an animation"]
                #[doc =
                  " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
                #[doc =
                  " - __`duration`__: duration of the animation in milliseconds"]
                #[doc =
                  " - __`delay`__: delay before the animation in milliseconds"]
                pub fn lv_anim_set_time(a: *mut lv_anim_t, duration: u16,
                                        delay: i16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_anim_set_time(a as *mut lv_anim_t, duration as u16,
                                 delay as i16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the start and end values of an animation"]
        #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
        #[doc = " - __`start`__: the start value"]
        #[doc = " - __`end`__: the end value"]
        pub fn anim_set_values(a: *mut lv_anim_t, start: lv_anim_value_t,
                               end: lv_anim_value_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the start and end values of an animation"]
                #[doc =
                  " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
                #[doc = " - __`start`__: the start value"]
                #[doc = " - __`end`__: the end value"]
                pub fn lv_anim_set_values(a: *mut lv_anim_t,
                                          start: lv_anim_value_t,
                                          end: lv_anim_value_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_anim_set_values(a as *mut lv_anim_t,
                                   start as lv_anim_value_t,
                                   end as lv_anim_value_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Similar to `lv_anim_set_var_and_cb` but `lv_anim_custom_exec_cb_t` receives"]
        #[doc = " `lv_anim_t * ` as its first parameter instead of `void *`."]
        #[doc =
          " This function might be used when LittlevGL is binded to other languages because"]
        #[doc =
          " it's more consistent to have `lv_anim_t *` as first parameter."]
        #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
        #[doc = " - __`exec_cb`__: a function to execute."]
        pub fn anim_set_custom_exec_cb(a: *mut lv_anim_t,
                                       exec_cb: lv_anim_custom_exec_cb_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Similar to `lv_anim_set_var_and_cb` but `lv_anim_custom_exec_cb_t` receives"]
                #[doc =
                  " `lv_anim_t * ` as its first parameter instead of `void *`."]
                #[doc =
                  " This function might be used when LittlevGL is binded to other languages because"]
                #[doc =
                  " it's more consistent to have `lv_anim_t *` as first parameter."]
                #[doc =
                  " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
                #[doc = " - __`exec_cb`__: a function to execute."]
                pub fn lv_anim_set_custom_exec_cb(a: *mut lv_anim_t,
                                                  exec_cb:
                                                      lv_anim_custom_exec_cb_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_anim_set_custom_exec_cb(a as *mut lv_anim_t,
                                           exec_cb as
                                               lv_anim_custom_exec_cb_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the path (curve) of the animation."]
        #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
        #[doc =
          " - __`path_cb`__: a function the get the current value of the animation."]
        #[doc =
          "                The built in functions starts with `lv_anim_path_...`"]
        pub fn anim_set_path_cb(a: *mut lv_anim_t, path_cb: lv_anim_path_cb_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the path (curve) of the animation."]
                #[doc =
                  " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
                #[doc =
                  " - __`path_cb`__: a function the get the current value of the animation."]
                #[doc =
                  "                The built in functions starts with `lv_anim_path_...`"]
                pub fn lv_anim_set_path_cb(a: *mut lv_anim_t,
                                           path_cb: lv_anim_path_cb_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_anim_set_path_cb(a as *mut lv_anim_t,
                                    path_cb as lv_anim_path_cb_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set a function call when the animation is ready"]
        #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
        #[doc =
          " - __`ready_cb`__: a function call when the animation is ready"]
        pub fn anim_set_ready_cb(a: *mut lv_anim_t,
                                 ready_cb: lv_anim_ready_cb_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a function call when the animation is ready"]
                #[doc =
                  " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
                #[doc =
                  " - __`ready_cb`__: a function call when the animation is ready"]
                pub fn lv_anim_set_ready_cb(a: *mut lv_anim_t,
                                            ready_cb: lv_anim_ready_cb_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_anim_set_ready_cb(a as *mut lv_anim_t,
                                     ready_cb as lv_anim_ready_cb_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Make the animation to play back to when the forward direction is ready"]
        #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
        #[doc =
          " - __`wait_time`__: time in milliseconds to wait before starting the back direction"]
        pub fn anim_set_playback(a: *mut lv_anim_t, wait_time: u16)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Make the animation to play back to when the forward direction is ready"]
                #[doc =
                  " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
                #[doc =
                  " - __`wait_time`__: time in milliseconds to wait before starting the back direction"]
                pub fn lv_anim_set_playback(a: *mut lv_anim_t,
                                            wait_time: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_anim_set_playback(a as *mut lv_anim_t, wait_time as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Disable playback. (Disabled after `lv_anim_init()`)"]
        #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
        pub fn anim_clear_playback(a: *mut lv_anim_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Disable playback. (Disabled after `lv_anim_init()`)"]
                #[doc =
                  " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
                pub fn lv_anim_clear_playback(a: *mut lv_anim_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_anim_clear_playback(a as *mut lv_anim_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Make the animation to start again when ready."]
        #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
        #[doc =
          " - __`wait_time`__: time in milliseconds to wait before starting the animation again"]
        pub fn anim_set_repeat(a: *mut lv_anim_t, wait_time: u16)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Make the animation to start again when ready."]
                #[doc =
                  " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
                #[doc =
                  " - __`wait_time`__: time in milliseconds to wait before starting the animation again"]
                pub fn lv_anim_set_repeat(a: *mut lv_anim_t, wait_time: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_anim_set_repeat(a as *mut lv_anim_t, wait_time as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Disable repeat. (Disabled after `lv_anim_init()`)"]
        #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
        pub fn anim_clear_repeat(a: *mut lv_anim_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Disable repeat. (Disabled after `lv_anim_init()`)"]
                #[doc =
                  " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
                pub fn lv_anim_clear_repeat(a: *mut lv_anim_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_anim_clear_repeat(a as *mut lv_anim_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Create an animation"]
        #[doc =
          " - __`a`__: an initialized 'anim_t' variable. Not required after call."]
        pub fn anim_create(a: *mut lv_anim_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create an animation"]
                #[doc =
                  " - __`a`__: an initialized 'anim_t' variable. Not required after call."]
                pub fn lv_anim_create(a: *mut lv_anim_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_anim_create(a as *mut lv_anim_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Delete an animation of a variable with a given animator function"]
        #[doc = " - __`var`__: pointer to variable"]
        #[doc =
          " - __`exec_cb`__: a function pointer which is animating 'var',"]
        #[doc =
          "           or NULL to ignore it and delete all the animations of 'var"]
        #[doc =
          " Return: true: at least 1 animation is deleted, false: no animation is deleted"]
        pub fn anim_del(var: Ptr, exec_cb: lv_anim_exec_xcb_t)
         -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Delete an animation of a variable with a given animator function"]
                #[doc = " - __`var`__: pointer to variable"]
                #[doc =
                  " - __`exec_cb`__: a function pointer which is animating 'var',"]
                #[doc =
                  "           or NULL to ignore it and delete all the animations of 'var"]
                #[doc =
                  " Return: true: at least 1 animation is deleted, false: no animation is deleted"]
                pub fn lv_anim_del(var: *mut ::cty::c_void,
                                   exec_cb: lv_anim_exec_xcb_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_anim_del(var as *mut ::cty::c_void,
                                exec_cb as lv_anim_exec_xcb_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Delete an aniamation by getting the animated variable from `a`."]
        #[doc = " Only animations with `exec_cb` will be deleted."]
        #[doc =
          " This function exist becasue it's logical that all anim functions receives an"]
        #[doc =
          " `lv_anim_t` as their first parameter. It's not practical in C but might makes"]
        #[doc =
          " the API more conequent and makes easier to genrate bindings."]
        #[doc = " - __`a`__: pointer to an animation."]
        #[doc =
          " - __`exec_cb`__: a function pointer which is animating 'var',"]
        #[doc =
          "           or NULL to ignore it and delete all the animations of 'var"]
        #[doc =
          " Return: true: at least 1 animation is deleted, false: no animation is deleted"]
        pub fn anim_custom_del(a: *mut lv_anim_t,
                               exec_cb: lv_anim_custom_exec_cb_t)
         -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Delete an aniamation by getting the animated variable from `a`."]
                #[doc = " Only animations with `exec_cb` will be deleted."]
                #[doc =
                  " This function exist becasue it's logical that all anim functions receives an"]
                #[doc =
                  " `lv_anim_t` as their first parameter. It's not practical in C but might makes"]
                #[doc =
                  " the API more conequent and makes easier to genrate bindings."]
                #[doc = " - __`a`__: pointer to an animation."]
                #[doc =
                  " - __`exec_cb`__: a function pointer which is animating 'var',"]
                #[doc =
                  "           or NULL to ignore it and delete all the animations of 'var"]
                #[doc =
                  " Return: true: at least 1 animation is deleted, false: no animation is deleted"]
                pub fn lv_anim_custom_del(a: *mut lv_anim_t,
                                          exec_cb: lv_anim_custom_exec_cb_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_anim_custom_del(a as *mut lv_anim_t,
                                       exec_cb as lv_anim_custom_exec_cb_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the number of currently running animations"]
        #[doc = " Return: the number of running animations"]
        pub fn anim_count_running() -> LvglResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the number of currently running animations"]
                #[doc = " Return: the number of running animations"]
                pub fn lv_anim_count_running()
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_anim_count_running();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Calculate the time of an animation with a given speed and the start and end values"]
        #[doc = " - __`speed`__: speed of animation in unit/sec"]
        #[doc = " - __`start`__: start value of the animation"]
        #[doc = " - __`end`__: end value of the animation"]
        #[doc =
          " Return: the required time [ms] for the animation with the given parameters"]
        pub fn anim_speed_to_time(speed: u16, start: lv_anim_value_t,
                                  end: lv_anim_value_t) -> LvglResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Calculate the time of an animation with a given speed and the start and end values"]
                #[doc = " - __`speed`__: speed of animation in unit/sec"]
                #[doc = " - __`start`__: start value of the animation"]
                #[doc = " - __`end`__: end value of the animation"]
                #[doc =
                  " Return: the required time [ms] for the animation with the given parameters"]
                pub fn lv_anim_speed_to_time(speed: u16,
                                             start: lv_anim_value_t,
                                             end: lv_anim_value_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_anim_speed_to_time(speed as u16,
                                          start as lv_anim_value_t,
                                          end as lv_anim_value_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Calculate the current value of an animation applying linear characteristic"]
        #[doc = " - __`a`__: pointer to an animation"]
        #[doc = " Return: the current value to set"]
        pub fn anim_path_linear(a: *const lv_anim_t)
         -> LvglResult<lv_anim_value_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Calculate the current value of an animation applying linear characteristic"]
                #[doc = " - __`a`__: pointer to an animation"]
                #[doc = " Return: the current value to set"]
                pub fn lv_anim_path_linear(a: *const lv_anim_t)
                -> lv_anim_value_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_anim_path_linear(a as *const lv_anim_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Calculate the current value of an animation slowing down the start phase"]
        #[doc = " - __`a`__: pointer to an animation"]
        #[doc = " Return: the current value to set"]
        pub fn anim_path_ease_in(a: *const lv_anim_t)
         -> LvglResult<lv_anim_value_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Calculate the current value of an animation slowing down the start phase"]
                #[doc = " - __`a`__: pointer to an animation"]
                #[doc = " Return: the current value to set"]
                pub fn lv_anim_path_ease_in(a: *const lv_anim_t)
                -> lv_anim_value_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_anim_path_ease_in(a as *const lv_anim_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Calculate the current value of an animation slowing down the end phase"]
        #[doc = " - __`a`__: pointer to an animation"]
        #[doc = " Return: the current value to set"]
        pub fn anim_path_ease_out(a: *const lv_anim_t)
         -> LvglResult<lv_anim_value_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Calculate the current value of an animation slowing down the end phase"]
                #[doc = " - __`a`__: pointer to an animation"]
                #[doc = " Return: the current value to set"]
                pub fn lv_anim_path_ease_out(a: *const lv_anim_t)
                -> lv_anim_value_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_anim_path_ease_out(a as *const lv_anim_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Calculate the current value of an animation applying an \"S\" characteristic (cosine)"]
        #[doc = " - __`a`__: pointer to an animation"]
        #[doc = " Return: the current value to set"]
        pub fn anim_path_ease_in_out(a: *const lv_anim_t)
         -> LvglResult<lv_anim_value_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Calculate the current value of an animation applying an \"S\" characteristic (cosine)"]
                #[doc = " - __`a`__: pointer to an animation"]
                #[doc = " Return: the current value to set"]
                pub fn lv_anim_path_ease_in_out(a: *const lv_anim_t)
                -> lv_anim_value_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_anim_path_ease_in_out(a as *const lv_anim_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Calculate the current value of an animation with overshoot at the end"]
        #[doc = " - __`a`__: pointer to an animation"]
        #[doc = " Return: the current value to set"]
        pub fn anim_path_overshoot(a: *const lv_anim_t)
         -> LvglResult<lv_anim_value_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Calculate the current value of an animation with overshoot at the end"]
                #[doc = " - __`a`__: pointer to an animation"]
                #[doc = " Return: the current value to set"]
                pub fn lv_anim_path_overshoot(a: *const lv_anim_t)
                -> lv_anim_value_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_anim_path_overshoot(a as *const lv_anim_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Calculate the current value of an animation with 3 bounces"]
        #[doc = " - __`a`__: pointer to an animation"]
        #[doc = " Return: the current value to set"]
        pub fn anim_path_bounce(a: *const lv_anim_t)
         -> LvglResult<lv_anim_value_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Calculate the current value of an animation with 3 bounces"]
                #[doc = " - __`a`__: pointer to an animation"]
                #[doc = " Return: the current value to set"]
                pub fn lv_anim_path_bounce(a: *const lv_anim_t)
                -> lv_anim_value_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_anim_path_bounce(a as *const lv_anim_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Calculate the current value of an animation applying step characteristic."]
        #[doc = " (Set end value on the end of the animation)"]
        #[doc = " - __`a`__: pointer to an animation"]
        #[doc = " Return: the current value to set"]
        pub fn anim_path_step(a: *const lv_anim_t)
         -> LvglResult<lv_anim_value_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Calculate the current value of an animation applying step characteristic."]
                #[doc = " (Set end value on the end of the animation)"]
                #[doc = " - __`a`__: pointer to an animation"]
                #[doc = " Return: the current value to set"]
                pub fn lv_anim_path_step(a: *const lv_anim_t)
                -> lv_anim_value_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_anim_path_step(a as *const lv_anim_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub const LV_BORDER_NONE: _bindgen_ty_5 = 0;
        pub const LV_BORDER_BOTTOM: _bindgen_ty_5 = 1;
        pub const LV_BORDER_TOP: _bindgen_ty_5 = 2;
        pub const LV_BORDER_LEFT: _bindgen_ty_5 = 4;
        pub const LV_BORDER_RIGHT: _bindgen_ty_5 = 8;
        pub const LV_BORDER_FULL: _bindgen_ty_5 = 15;
        #[doc = "< FOR matrix-like objects (e.g. Button matrix)"]
        pub const LV_BORDER_INTERNAL: _bindgen_ty_5 = 16;
        #[doc = "      TYPEDEFS"]
        pub type _bindgen_ty_5 = u8;
        pub type lv_border_part_t = u8;
        #[doc = "< Only draw bottom shadow"]
        pub const LV_SHADOW_BOTTOM: _bindgen_ty_6 = 0;
        #[doc = "< Draw shadow on all sides"]
        pub const LV_SHADOW_FULL: _bindgen_ty_6 = 1;
        pub type _bindgen_ty_6 = u8;
        pub type lv_shadow_type_t = u8;
        #[doc =
          " Objects in LittlevGL can be assigned a style - which holds information about"]
        #[doc = " how the object should be drawn."]
        #[doc = ""]
        #[doc =
          " This allows for easy customization without having to modify the object's design"]
        #[doc = " function."]
        #[repr(C)]
        pub struct lv_style_t {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub body: lv_style_t__bindgen_ty_1,
            pub text: lv_style_t__bindgen_ty_2,
            pub image: lv_style_t__bindgen_ty_3,
            pub line: lv_style_t__bindgen_ty_4,
        }
        #[doc = " Object background."]
        #[repr(C)]
        pub struct lv_style_t__bindgen_ty_1 {
            #[doc = "< Object's main background color."]
            pub main_color: lv_color_t,
            #[doc =
              "< Second color. If not equal to `main_color` a gradient will be drawn for the background."]
            pub grad_color: lv_color_t,
            #[doc =
              "< Object's corner radius. You can use #LV_RADIUS_CIRCLE if you want to draw a circle."]
            pub radius: lv_coord_t,
            #[doc = "< Object's opacity (0-255)."]
            pub opa: lv_opa_t,
            pub border: lv_style_t__bindgen_ty_1__bindgen_ty_1,
            pub shadow: lv_style_t__bindgen_ty_1__bindgen_ty_2,
            pub padding: lv_style_t__bindgen_ty_1__bindgen_ty_3,
        }
        #[repr(C)]
        pub struct lv_style_t__bindgen_ty_1__bindgen_ty_1 {
            #[doc = "< Border color"]
            pub color: lv_color_t,
            #[doc = "< Border width"]
            pub width: lv_coord_t,
            #[doc = "< Which borders to draw"]
            pub part: lv_border_part_t,
            #[doc = "< Border opacity."]
            pub opa: lv_opa_t,
        }
        impl Default for lv_style_t__bindgen_ty_1__bindgen_ty_1 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[repr(C)]
        pub struct lv_style_t__bindgen_ty_1__bindgen_ty_2 {
            pub color: lv_color_t,
            pub width: lv_coord_t,
            #[doc = "< Which parts of the shadow to draw"]
            pub type_: lv_shadow_type_t,
        }
        impl Default for lv_style_t__bindgen_ty_1__bindgen_ty_2 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[repr(C)]
        pub struct lv_style_t__bindgen_ty_1__bindgen_ty_3 {
            pub top: lv_coord_t,
            pub bottom: lv_coord_t,
            pub left: lv_coord_t,
            pub right: lv_coord_t,
            pub inner: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for
         lv_style_t__bindgen_ty_1__bindgen_ty_3 {
            #[inline]
            fn default() -> lv_style_t__bindgen_ty_1__bindgen_ty_3 {
                lv_style_t__bindgen_ty_1__bindgen_ty_3{top:
                                                           ::core::default::Default::default(),
                                                       bottom:
                                                           ::core::default::Default::default(),
                                                       left:
                                                           ::core::default::Default::default(),
                                                       right:
                                                           ::core::default::Default::default(),
                                                       inner:
                                                           ::core::default::Default::default(),}
            }
        }
        impl Default for lv_style_t__bindgen_ty_1 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = " Style for text drawn by this object."]
        #[repr(C)]
        pub struct lv_style_t__bindgen_ty_2 {
            #[doc = "< Text color"]
            pub color: lv_color_t,
            #[doc = "< Text selection background color."]
            pub sel_color: lv_color_t,
            pub font: *const lv_font_t,
            #[doc = "< Space between letters"]
            pub letter_space: lv_coord_t,
            #[doc = "< Space between lines (vertical)"]
            pub line_space: lv_coord_t,
            #[doc = "< Text opacity"]
            pub opa: lv_opa_t,
        }
        impl Default for lv_style_t__bindgen_ty_2 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[repr(C)]
        pub struct lv_style_t__bindgen_ty_3 {
            #[doc = "< Color to recolor the image with"]
            pub color: lv_color_t,
            #[doc = "< Opacity of recoloring (0 means no recoloring)"]
            pub intense: lv_opa_t,
            #[doc = "< Opacity of whole image"]
            pub opa: lv_opa_t,
        }
        impl Default for lv_style_t__bindgen_ty_3 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[repr(C)]
        pub struct lv_style_t__bindgen_ty_4 {
            pub color: lv_color_t,
            pub width: lv_coord_t,
            pub opa: lv_opa_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
        }
        impl Default for lv_style_t__bindgen_ty_4 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_t__bindgen_ty_4 {
            #[inline]
            pub fn rounded(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_rounded(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(rounded: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let rounded: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(rounded)
                                                    };
                                                rounded as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_style_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_t {
            #[inline]
            pub fn glass(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_glass(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(glass: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let glass: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(glass)
                                                    };
                                                glass as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Data structure for style animations."]
        #[repr(C)]
        pub struct lv_style_anim_dsc_t {
            pub style_start: lv_style_t,
            pub style_end: lv_style_t,
            pub style_anim: *mut lv_style_t,
            pub ready_cb: lv_anim_ready_cb_t,
        }
        impl Default for lv_style_anim_dsc_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = "  Init the basic styles"]
        pub fn style_init() -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = "  Init the basic styles"]
                pub fn lv_style_init();
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_style_init();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Copy a style to an other"]
        #[doc = " - __`dest`__: pointer to the destination style"]
        #[doc = " - __`src`__: pointer to the source style"]
        pub fn style_copy(dest: *mut lv_style_t, src: *const lv_style_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Copy a style to an other"]
                #[doc = " - __`dest`__: pointer to the destination style"]
                #[doc = " - __`src`__: pointer to the source style"]
                pub fn lv_style_copy(dest: *mut lv_style_t,
                                     src: *const lv_style_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_style_copy(dest as *mut lv_style_t,
                              src as *const lv_style_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Mix two styles according to a given ratio"]
        #[doc = " - __`start`__: start style"]
        #[doc = " - __`end`__: end style"]
        #[doc = " - __`res`__: store the result style here"]
        #[doc =
          " - __`ratio`__: the ratio of mix [0..256]; 0: `start` style; 256: `end` style"]
        pub fn style_mix(start: *const lv_style_t, end: *const lv_style_t,
                         res: *mut lv_style_t, ratio: u16) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Mix two styles according to a given ratio"]
                #[doc = " - __`start`__: start style"]
                #[doc = " - __`end`__: end style"]
                #[doc = " - __`res`__: store the result style here"]
                #[doc =
                  " - __`ratio`__: the ratio of mix [0..256]; 0: `start` style; 256: `end` style"]
                pub fn lv_style_mix(start: *const lv_style_t,
                                    end: *const lv_style_t,
                                    res: *mut lv_style_t, ratio: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_style_mix(start as *const lv_style_t,
                             end as *const lv_style_t, res as *mut lv_style_t,
                             ratio as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Initialize an animation variable."]
        #[doc = " E.g.:"]
        #[doc = " lv_anim_t a;"]
        #[doc = " lv_style_anim__init(&a);"]
        #[doc = " lv_style_anim_set_...(&a);"]
        #[doc = " lv_style_anim_create(&a);"]
        #[doc =
          " - __`a`__: pointer to an `lv_anim_t` variable to initialize"]
        pub fn style_anim_init(a: *mut lv_anim_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Initialize an animation variable."]
                #[doc = " E.g.:"]
                #[doc = " lv_anim_t a;"]
                #[doc = " lv_style_anim__init(&a);"]
                #[doc = " lv_style_anim_set_...(&a);"]
                #[doc = " lv_style_anim_create(&a);"]
                #[doc =
                  " - __`a`__: pointer to an `lv_anim_t` variable to initialize"]
                pub fn lv_style_anim_init(a: *mut lv_anim_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_style_anim_init(a as *mut lv_anim_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
        #[doc = " - __`to_anim`__: pointer to the style to animate"]
        #[doc =
          " - __`start`__: pointer to a style to animate from (start value)"]
        #[doc = " - __`end`__: pointer to a style to animate to (end value)"]
        pub fn style_anim_set_styles(a: *mut lv_anim_t,
                                     to_anim: *mut lv_style_t,
                                     start: *const lv_style_t,
                                     end: *const lv_style_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
                #[doc = " - __`to_anim`__: pointer to the style to animate"]
                #[doc =
                  " - __`start`__: pointer to a style to animate from (start value)"]
                #[doc =
                  " - __`end`__: pointer to a style to animate to (end value)"]
                pub fn lv_style_anim_set_styles(a: *mut lv_anim_t,
                                                to_anim: *mut lv_style_t,
                                                start: *const lv_style_t,
                                                end: *const lv_style_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_style_anim_set_styles(a as *mut lv_anim_t,
                                         to_anim as *mut lv_style_t,
                                         start as *const lv_style_t,
                                         end as *const lv_style_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the duration and delay of an animation"]
        #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
        #[doc =
          " - __`duration`__: duration of the animation in milliseconds"]
        #[doc = " - __`delay`__: delay before the animation in milliseconds"]
        pub fn style_anim_set_time(a: *mut lv_anim_t, duration: u16,
                                   delay: i16) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the duration and delay of an animation"]
                #[doc =
                  " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
                #[doc =
                  " - __`duration`__: duration of the animation in milliseconds"]
                #[doc =
                  " - __`delay`__: delay before the animation in milliseconds"]
                pub fn lv_style_anim_set_time(a: *mut lv_anim_t,
                                              duration: u16, delay: i16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_style_anim_set_time(a as *mut lv_anim_t, duration as u16,
                                       delay as i16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set a function call when the animation is ready"]
        #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
        #[doc =
          " - __`ready_cb`__: a function call when the animation is ready"]
        pub fn style_anim_set_ready_cb(a: *mut lv_anim_t,
                                       ready_cb: lv_anim_ready_cb_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a function call when the animation is ready"]
                #[doc =
                  " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
                #[doc =
                  " - __`ready_cb`__: a function call when the animation is ready"]
                pub fn lv_style_anim_set_ready_cb(a: *mut lv_anim_t,
                                                  ready_cb:
                                                      lv_anim_ready_cb_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_style_anim_set_ready_cb(a as *mut lv_anim_t,
                                           ready_cb as lv_anim_ready_cb_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Make the animation to play back to when the forward direction is ready"]
        #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
        #[doc =
          " - __`wait_time`__: time in milliseconds to wait before starting the back direction"]
        pub fn style_anim_set_playback(a: *mut lv_anim_t, wait_time: u16)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Make the animation to play back to when the forward direction is ready"]
                #[doc =
                  " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
                #[doc =
                  " - __`wait_time`__: time in milliseconds to wait before starting the back direction"]
                pub fn lv_style_anim_set_playback(a: *mut lv_anim_t,
                                                  wait_time: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_style_anim_set_playback(a as *mut lv_anim_t,
                                           wait_time as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Disable playback. (Disabled after `lv_anim_init()`)"]
        #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
        pub fn style_anim_clear_playback(a: *mut lv_anim_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Disable playback. (Disabled after `lv_anim_init()`)"]
                #[doc =
                  " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
                pub fn lv_style_anim_clear_playback(a: *mut lv_anim_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_style_anim_clear_playback(a as *mut lv_anim_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Make the animation to start again when ready."]
        #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
        #[doc =
          " - __`wait_time`__: time in milliseconds to wait before starting the animation again"]
        pub fn style_anim_set_repeat(a: *mut lv_anim_t, wait_time: u16)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Make the animation to start again when ready."]
                #[doc =
                  " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
                #[doc =
                  " - __`wait_time`__: time in milliseconds to wait before starting the animation again"]
                pub fn lv_style_anim_set_repeat(a: *mut lv_anim_t,
                                                wait_time: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_style_anim_set_repeat(a as *mut lv_anim_t,
                                         wait_time as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Disable repeat. (Disabled after `lv_anim_init()`)"]
        #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
        pub fn style_anim_clear_repeat(a: *mut lv_anim_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Disable repeat. (Disabled after `lv_anim_init()`)"]
                #[doc =
                  " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
                pub fn lv_style_anim_clear_repeat(a: *mut lv_anim_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_style_anim_clear_repeat(a as *mut lv_anim_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Create an animation"]
        #[doc =
          " - __`a`__: an initialized 'anim_t' variable. Not required after call."]
        pub fn style_anim_create(a: *mut lv_anim_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create an animation"]
                #[doc =
                  " - __`a`__: an initialized 'anim_t' variable. Not required after call."]
                pub fn lv_style_anim_create(a: *mut lv_anim_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_style_anim_create(a as *mut lv_anim_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        extern "C" {
            pub static mut lv_style_scr: lv_style_t;
        }
        extern "C" {
            pub static mut lv_style_transp: lv_style_t;
        }
        extern "C" {
            pub static mut lv_style_transp_fit: lv_style_t;
        }
        extern "C" {
            pub static mut lv_style_transp_tight: lv_style_t;
        }
        extern "C" {
            pub static mut lv_style_plain: lv_style_t;
        }
        extern "C" {
            pub static mut lv_style_plain_color: lv_style_t;
        }
        extern "C" {
            pub static mut lv_style_pretty: lv_style_t;
        }
        extern "C" {
            pub static mut lv_style_pretty_color: lv_style_t;
        }
        extern "C" {
            pub static mut lv_style_btn_rel: lv_style_t;
        }
        extern "C" {
            pub static mut lv_style_btn_pr: lv_style_t;
        }
        extern "C" {
            pub static mut lv_style_btn_tgl_rel: lv_style_t;
        }
        extern "C" {
            pub static mut lv_style_btn_tgl_pr: lv_style_t;
        }
        extern "C" {
            pub static mut lv_style_btn_ina: lv_style_t;
        }
        pub const LV_RES_INV: _bindgen_ty_7 = 0;
        pub const LV_RES_OK: _bindgen_ty_7 = 1;
        #[doc = " LittlevGL error codes."]
        pub type _bindgen_ty_7 = u8;
        pub type lv_res_t = u8;
        pub type lv_uintptr_t = u64;
        pub type lv_log_level_t = i8;
        #[doc = " Heap information structure."]
        #[repr(C)]
        pub struct lv_mem_monitor_t {
            #[doc = "< Total heap size"]
            pub total_size: u32,
            pub free_cnt: u32,
            #[doc = "< Size of available memory"]
            pub free_size: u32,
            pub free_biggest_size: u32,
            pub used_cnt: u32,
            #[doc = "< Percentage used"]
            pub used_pct: u8,
            #[doc = "< Amount of fragmentation"]
            pub frag_pct: u8,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_mem_monitor_t {
            #[inline]
            fn default() -> lv_mem_monitor_t {
                lv_mem_monitor_t{total_size:
                                     ::core::default::Default::default(),
                                 free_cnt:
                                     ::core::default::Default::default(),
                                 free_size:
                                     ::core::default::Default::default(),
                                 free_biggest_size:
                                     ::core::default::Default::default(),
                                 used_cnt:
                                     ::core::default::Default::default(),
                                 used_pct:
                                     ::core::default::Default::default(),
                                 frag_pct:
                                     ::core::default::Default::default(),}
            }
        }
        #[doc =
          " Initiaize the dyn_mem module (work memory and other variables)"]
        pub fn mem_init() -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Initiaize the dyn_mem module (work memory and other variables)"]
                pub fn lv_mem_init();
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_mem_init();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Allocate a memory dynamically"]
        #[doc = " - __`size`__: size of the memory to allocate in bytes"]
        #[doc = " Return: pointer to the allocated memory"]
        pub fn mem_alloc(size: usize) -> LvglResult<*mut ::cty::c_void> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Allocate a memory dynamically"]
                #[doc =
                  " - __`size`__: size of the memory to allocate in bytes"]
                #[doc = " Return: pointer to the allocated memory"]
                pub fn lv_mem_alloc(size: usize)
                -> *mut ::cty::c_void;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_mem_alloc(size as usize);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Free an allocated data"]
        #[doc = " - __`data`__: pointer to an allocated memory"]
        pub fn mem_free(data: *const ::cty::c_void) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Free an allocated data"]
                #[doc = " - __`data`__: pointer to an allocated memory"]
                pub fn lv_mem_free(data: *const ::cty::c_void);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_mem_free(data as *const ::cty::c_void);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Reallocate a memory with a new size. The old content will be kept."]
        #[doc = " - __`data`__: pointer to an allocated memory."]
        #[doc =
          " Its content will be copied to the new memory block and freed"]
        #[doc = " - __`new_size`__: the desired new size in byte"]
        #[doc = " Return: pointer to the new memory"]
        pub fn mem_realloc(data_p: Ptr, new_size: usize)
         -> LvglResult<*mut ::cty::c_void> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Reallocate a memory with a new size. The old content will be kept."]
                #[doc = " - __`data`__: pointer to an allocated memory."]
                #[doc =
                  " Its content will be copied to the new memory block and freed"]
                #[doc = " - __`new_size`__: the desired new size in byte"]
                #[doc = " Return: pointer to the new memory"]
                pub fn lv_mem_realloc(data_p: *mut ::cty::c_void,
                                      new_size: usize)
                -> *mut ::cty::c_void;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_mem_realloc(data_p as *mut ::cty::c_void,
                                   new_size as usize);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Join the adjacent free memory blocks"]
        pub fn mem_defrag() -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Join the adjacent free memory blocks"]
                pub fn lv_mem_defrag();
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_mem_defrag();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Give information about the work memory of dynamic allocation"]
        #[doc = " - __`mon_p`__: pointer to a dm_mon_p variable,"]
        #[doc =
          "              the result of the analysis will be stored here"]
        pub fn mem_monitor(mon_p: *mut lv_mem_monitor_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Give information about the work memory of dynamic allocation"]
                #[doc = " - __`mon_p`__: pointer to a dm_mon_p variable,"]
                #[doc =
                  "              the result of the analysis will be stored here"]
                pub fn lv_mem_monitor(mon_p: *mut lv_mem_monitor_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_mem_monitor(mon_p as *mut lv_mem_monitor_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Give the size of an allocated memory"]
        #[doc = " - __`data`__: pointer to an allocated memory"]
        #[doc = " Return: the size of data memory in bytes"]
        pub fn mem_get_size(data: *const ::cty::c_void) -> LvglResult<u32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Give the size of an allocated memory"]
                #[doc = " - __`data`__: pointer to an allocated memory"]
                #[doc = " Return: the size of data memory in bytes"]
                pub fn lv_mem_get_size(data: *const ::cty::c_void)
                -> u32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_mem_get_size(data as *const ::cty::c_void);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = " Initialize linked list"]
        #[doc = " - __`ll_dsc`__: pointer to ll_dsc variable"]
        #[doc = " - __`node_size`__: the size of 1 node in bytes"]
        pub fn ll_init(ll_p: *mut lv_ll_t, node_size: u32) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Initialize linked list"]
                #[doc = " - __`ll_dsc`__: pointer to ll_dsc variable"]
                #[doc = " - __`node_size`__: the size of 1 node in bytes"]
                pub fn lv_ll_init(ll_p: *mut lv_ll_t, node_size: u32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_ll_init(ll_p as *mut lv_ll_t, node_size as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Add a new head to a linked list"]
        #[doc = " - __`ll_p`__: pointer to linked list"]
        #[doc = " Return: pointer to the new head"]
        pub fn ll_ins_head(ll_p: *mut lv_ll_t)
         -> LvglResult<*mut ::cty::c_void> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Add a new head to a linked list"]
                #[doc = " - __`ll_p`__: pointer to linked list"]
                #[doc = " Return: pointer to the new head"]
                pub fn lv_ll_ins_head(ll_p: *mut lv_ll_t)
                -> *mut ::cty::c_void;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_ll_ins_head(ll_p as *mut lv_ll_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Insert a new node in front of the n_act node"]
        #[doc = " - __`ll_p`__: pointer to linked list"]
        #[doc = " - __`n_act`__: pointer a node"]
        #[doc = " Return: pointer to the new head"]
        pub fn ll_ins_prev(ll_p: *mut lv_ll_t, n_act: Ptr)
         -> LvglResult<*mut ::cty::c_void> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Insert a new node in front of the n_act node"]
                #[doc = " - __`ll_p`__: pointer to linked list"]
                #[doc = " - __`n_act`__: pointer a node"]
                #[doc = " Return: pointer to the new head"]
                pub fn lv_ll_ins_prev(ll_p: *mut lv_ll_t,
                                      n_act: *mut ::cty::c_void)
                -> *mut ::cty::c_void;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_ll_ins_prev(ll_p as *mut lv_ll_t,
                                   n_act as *mut ::cty::c_void);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Add a new tail to a linked list"]
        #[doc = " - __`ll_p`__: pointer to linked list"]
        #[doc = " Return: pointer to the new tail"]
        pub fn ll_ins_tail(ll_p: *mut lv_ll_t)
         -> LvglResult<*mut ::cty::c_void> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Add a new tail to a linked list"]
                #[doc = " - __`ll_p`__: pointer to linked list"]
                #[doc = " Return: pointer to the new tail"]
                pub fn lv_ll_ins_tail(ll_p: *mut lv_ll_t)
                -> *mut ::cty::c_void;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_ll_ins_tail(ll_p as *mut lv_ll_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Remove the node 'node_p' from 'll_p' linked list."]
        #[doc = " It does not free the the memory of node."]
        #[doc = " - __`ll_p`__: pointer to the linked list of 'node_p'"]
        #[doc = " - __`node_p`__: pointer to node in 'll_p' linked list"]
        pub fn ll_rem(ll_p: *mut lv_ll_t, node_p: Ptr) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Remove the node 'node_p' from 'll_p' linked list."]
                #[doc = " It does not free the the memory of node."]
                #[doc =
                  " - __`ll_p`__: pointer to the linked list of 'node_p'"]
                #[doc =
                  " - __`node_p`__: pointer to node in 'll_p' linked list"]
                pub fn lv_ll_rem(ll_p: *mut lv_ll_t,
                                 node_p: *mut ::cty::c_void);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_ll_rem(ll_p as *mut lv_ll_t, node_p as *mut ::cty::c_void);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Remove and free all elements from a linked list. The list remain valid but become empty."]
        #[doc = " - __`ll_p`__: pointer to linked list"]
        pub fn ll_clear(ll_p: *mut lv_ll_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Remove and free all elements from a linked list. The list remain valid but become empty."]
                #[doc = " - __`ll_p`__: pointer to linked list"]
                pub fn lv_ll_clear(ll_p: *mut lv_ll_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_ll_clear(ll_p as *mut lv_ll_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Move a node to a new linked list"]
        #[doc =
          " - __`ll_ori_p`__: pointer to the original (old) linked list"]
        #[doc = " - __`ll_new_p`__: pointer to the new linked list"]
        #[doc = " - __`node`__: pointer to a node"]
        #[doc = " - __`head`__: true: be the head in the new list"]
        #[doc = "             false be the head in the new list"]
        pub fn ll_chg_list(ll_ori_p: *mut lv_ll_t, ll_new_p: *mut lv_ll_t,
                           node: Ptr, head: bool) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Move a node to a new linked list"]
                #[doc =
                  " - __`ll_ori_p`__: pointer to the original (old) linked list"]
                #[doc = " - __`ll_new_p`__: pointer to the new linked list"]
                #[doc = " - __`node`__: pointer to a node"]
                #[doc = " - __`head`__: true: be the head in the new list"]
                #[doc = "             false be the head in the new list"]
                pub fn lv_ll_chg_list(ll_ori_p: *mut lv_ll_t,
                                      ll_new_p: *mut lv_ll_t,
                                      node: *mut ::cty::c_void, head: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_ll_chg_list(ll_ori_p as *mut lv_ll_t,
                               ll_new_p as *mut lv_ll_t,
                               node as *mut ::cty::c_void, head as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Return with head node of the linked list"]
        #[doc = " - __`ll_p`__: pointer to linked list"]
        #[doc = " Return: pointer to the head of 'll_p'"]
        pub fn ll_get_head(ll_p: *const lv_ll_t)
         -> LvglResult<*mut ::cty::c_void> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Return with head node of the linked list"]
                #[doc = " - __`ll_p`__: pointer to linked list"]
                #[doc = " Return: pointer to the head of 'll_p'"]
                pub fn lv_ll_get_head(ll_p: *const lv_ll_t)
                -> *mut ::cty::c_void;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_ll_get_head(ll_p as *const lv_ll_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Return with tail node of the linked list"]
        #[doc = " - __`ll_p`__: pointer to linked list"]
        #[doc = " Return: pointer to the head of 'll_p'"]
        pub fn ll_get_tail(ll_p: *const lv_ll_t)
         -> LvglResult<*mut ::cty::c_void> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Return with tail node of the linked list"]
                #[doc = " - __`ll_p`__: pointer to linked list"]
                #[doc = " Return: pointer to the head of 'll_p'"]
                pub fn lv_ll_get_tail(ll_p: *const lv_ll_t)
                -> *mut ::cty::c_void;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_ll_get_tail(ll_p as *const lv_ll_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Return with the pointer of the next node after 'n_act'"]
        #[doc = " - __`ll_p`__: pointer to linked list"]
        #[doc = " - __`n_act`__: pointer a node"]
        #[doc = " Return: pointer to the next node"]
        pub fn ll_get_next(ll_p: *const lv_ll_t, n_act: *const ::cty::c_void)
         -> LvglResult<*mut ::cty::c_void> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Return with the pointer of the next node after 'n_act'"]
                #[doc = " - __`ll_p`__: pointer to linked list"]
                #[doc = " - __`n_act`__: pointer a node"]
                #[doc = " Return: pointer to the next node"]
                pub fn lv_ll_get_next(ll_p: *const lv_ll_t,
                                      n_act: *const ::cty::c_void)
                -> *mut ::cty::c_void;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_ll_get_next(ll_p as *const lv_ll_t,
                                   n_act as *const ::cty::c_void);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Return with the pointer of the previous node after 'n_act'"]
        #[doc = " - __`ll_p`__: pointer to linked list"]
        #[doc = " - __`n_act`__: pointer a node"]
        #[doc = " Return: pointer to the previous node"]
        pub fn ll_get_prev(ll_p: *const lv_ll_t, n_act: *const ::cty::c_void)
         -> LvglResult<*mut ::cty::c_void> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Return with the pointer of the previous node after 'n_act'"]
                #[doc = " - __`ll_p`__: pointer to linked list"]
                #[doc = " - __`n_act`__: pointer a node"]
                #[doc = " Return: pointer to the previous node"]
                pub fn lv_ll_get_prev(ll_p: *const lv_ll_t,
                                      n_act: *const ::cty::c_void)
                -> *mut ::cty::c_void;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_ll_get_prev(ll_p as *const lv_ll_t,
                                   n_act as *const ::cty::c_void);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Return the length of the linked list."]
        #[doc = " - __`ll_p`__: pointer to linked list"]
        #[doc = " Return: length of the linked list"]
        pub fn ll_get_len(ll_p: *const lv_ll_t) -> LvglResult<u32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Return the length of the linked list."]
                #[doc = " - __`ll_p`__: pointer to linked list"]
                #[doc = " Return: length of the linked list"]
                pub fn lv_ll_get_len(ll_p: *const lv_ll_t)
                -> u32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_ll_get_len(ll_p as *const lv_ll_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Move a nodw before an other node in the same linked list"]
        #[doc = " - __`ll_p`__: pointer to a linked list"]
        #[doc = " - __`n_act`__: pointer to node to move"]
        #[doc =
          " - __`n_after`__: pointer to a node which should be after `n_act`"]
        pub fn ll_move_before(ll_p: *mut lv_ll_t, n_act: Ptr, n_after: Ptr)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Move a nodw before an other node in the same linked list"]
                #[doc = " - __`ll_p`__: pointer to a linked list"]
                #[doc = " - __`n_act`__: pointer to node to move"]
                #[doc =
                  " - __`n_after`__: pointer to a node which should be after `n_act`"]
                pub fn lv_ll_move_before(ll_p: *mut lv_ll_t,
                                         n_act: *mut ::cty::c_void,
                                         n_after: *mut ::cty::c_void);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_ll_move_before(ll_p as *mut lv_ll_t,
                                  n_act as *mut ::cty::c_void,
                                  n_after as *mut ::cty::c_void);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Check if a linked list is empty"]
        #[doc = " - __`ll_p`__: pointer to a linked list"]
        #[doc = " Return: true: the linked list is empty; false: not empty"]
        pub fn ll_is_empty(ll_p: *mut lv_ll_t) -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Check if a linked list is empty"]
                #[doc = " - __`ll_p`__: pointer to a linked list"]
                #[doc =
                  " Return: true: the linked list is empty; false: not empty"]
                pub fn lv_ll_is_empty(ll_p: *mut lv_ll_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_ll_is_empty(ll_p as *mut lv_ll_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub const LV_BIDI_DIR_LTR: _bindgen_ty_8 = 0;
        pub const LV_BIDI_DIR_RTL: _bindgen_ty_8 = 1;
        pub const LV_BIDI_DIR_AUTO: _bindgen_ty_8 = 2;
        pub const LV_BIDI_DIR_INHERIT: _bindgen_ty_8 = 3;
        pub const LV_BIDI_DIR_NEUTRAL: _bindgen_ty_8 = 32;
        pub const LV_BIDI_DIR_WEAK: _bindgen_ty_8 = 33;
        #[doc = "      TYPEDEFS"]
        pub type _bindgen_ty_8 = u8;
        pub type lv_bidi_dir_t = u8;
        #[doc = " Tasks execute this type type of functions."]
        pub type lv_task_cb_t
            =
            ::core::option::Option<unsafe extern "C" fn(arg1:
                                                            *mut _lv_task_t)>;
        pub const LV_TASK_PRIO_OFF: _bindgen_ty_9 = 0;
        pub const LV_TASK_PRIO_LOWEST: _bindgen_ty_9 = 1;
        pub const LV_TASK_PRIO_LOW: _bindgen_ty_9 = 2;
        pub const LV_TASK_PRIO_MID: _bindgen_ty_9 = 3;
        pub const LV_TASK_PRIO_HIGH: _bindgen_ty_9 = 4;
        pub const LV_TASK_PRIO_HIGHEST: _bindgen_ty_9 = 5;
        pub const _LV_TASK_PRIO_NUM: _bindgen_ty_9 = 6;
        #[doc = " Possible priorities for lv_tasks"]
        pub type _bindgen_ty_9 = u8;
        pub type lv_task_prio_t = u8;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct _lv_task_t {
            #[doc = "< How often the task should run"]
            pub period: u32,
            #[doc = "< Last time the task ran"]
            pub last_run: u32,
            #[doc = "< Task function"]
            pub task_cb: lv_task_cb_t,
            #[doc = "< Custom user data"]
            pub user_data: *mut ::cty::c_void,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for _lv_task_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_task_t {
            #[inline]
            pub fn prio(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_prio(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn once(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_once(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(prio: u8, once: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 3u8,
                                            {
                                                let prio: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(prio)
                                                    };
                                                prio as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let once: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(once)
                                                    };
                                                once as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_task_t = _lv_task_t;
        #[doc = " Init the lv_task module"]
        pub fn task_core_init() -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Init the lv_task module"]
                pub fn lv_task_core_init();
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_task_core_init();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Call it  periodically to handle lv_tasks."]
        pub fn task_handler() -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Call it  periodically to handle lv_tasks."]
                pub fn lv_task_handler();
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_task_handler();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Create an \"empty\" task. It needs to initialzed with at least"]
        #[doc = " `lv_task_set_cb` and `lv_task_set_period`"]
        #[doc = " Return: pointer to the craeted task"]
        pub fn task_create_basic() -> LvglResult<*mut lv_task_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Create an \"empty\" task. It needs to initialzed with at least"]
                #[doc = " `lv_task_set_cb` and `lv_task_set_period`"]
                #[doc = " Return: pointer to the craeted task"]
                pub fn lv_task_create_basic()
                -> *mut lv_task_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_task_create_basic();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Create a new lv_task"]
        #[doc =
          " - __`task_xcb`__: a callback which is the task itself. It will be called periodically."]
        #[doc =
          "                 (the 'x' in the argument name indicates that its not a fully generic function because it not follows"]
        #[doc =
          "                  the `func_name(object, callback, ...)` convention)"]
        #[doc = " - __`period`__: call period in ms unit"]
        #[doc =
          " - __`prio`__: priority of the task (LV_TASK_PRIO_OFF means the task is stopped)"]
        #[doc = " - __`user_data`__: custom parameter"]
        #[doc = " Return: pointer to the new task"]
        pub fn task_create(task_xcb: lv_task_cb_t, period: u32,
                           prio: lv_task_prio_t, user_data: Ptr)
         -> LvglResult<*mut lv_task_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a new lv_task"]
                #[doc =
                  " - __`task_xcb`__: a callback which is the task itself. It will be called periodically."]
                #[doc =
                  "                 (the 'x' in the argument name indicates that its not a fully generic function because it not follows"]
                #[doc =
                  "                  the `func_name(object, callback, ...)` convention)"]
                #[doc = " - __`period`__: call period in ms unit"]
                #[doc =
                  " - __`prio`__: priority of the task (LV_TASK_PRIO_OFF means the task is stopped)"]
                #[doc = " - __`user_data`__: custom parameter"]
                #[doc = " Return: pointer to the new task"]
                pub fn lv_task_create(task_xcb: lv_task_cb_t, period: u32,
                                      prio: lv_task_prio_t,
                                      user_data: *mut ::cty::c_void)
                -> *mut lv_task_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_task_create(task_xcb as lv_task_cb_t, period as u32,
                                   prio as lv_task_prio_t,
                                   user_data as *mut ::cty::c_void);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Delete a lv_task"]
        #[doc = " - __`task`__: pointer to task_cb created by task"]
        pub fn task_del(task: *mut lv_task_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Delete a lv_task"]
                #[doc = " - __`task`__: pointer to task_cb created by task"]
                pub fn lv_task_del(task: *mut lv_task_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_task_del(task as *mut lv_task_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the callback the task (the function to call periodically)"]
        #[doc = " - __`task`__: pointer to a task"]
        #[doc = " - __`task_cb`__: the function to call periodically"]
        pub fn task_set_cb(task: *mut lv_task_t, task_cb: lv_task_cb_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the callback the task (the function to call periodically)"]
                #[doc = " - __`task`__: pointer to a task"]
                #[doc = " - __`task_cb`__: the function to call periodically"]
                pub fn lv_task_set_cb(task: *mut lv_task_t,
                                      task_cb: lv_task_cb_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_task_set_cb(task as *mut lv_task_t,
                               task_cb as lv_task_cb_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set new priority for a lv_task"]
        #[doc = " - __`task`__: pointer to a lv_task"]
        #[doc = " - __`prio`__: the new priority"]
        pub fn task_set_prio(task: *mut lv_task_t, prio: lv_task_prio_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set new priority for a lv_task"]
                #[doc = " - __`task`__: pointer to a lv_task"]
                #[doc = " - __`prio`__: the new priority"]
                pub fn lv_task_set_prio(task: *mut lv_task_t,
                                        prio: lv_task_prio_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_task_set_prio(task as *mut lv_task_t,
                                 prio as lv_task_prio_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set new period for a lv_task"]
        #[doc = " - __`task`__: pointer to a lv_task"]
        #[doc = " - __`period`__: the new period"]
        pub fn task_set_period(task: *mut lv_task_t, period: u32)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set new period for a lv_task"]
                #[doc = " - __`task`__: pointer to a lv_task"]
                #[doc = " - __`period`__: the new period"]
                pub fn lv_task_set_period(task: *mut lv_task_t, period: u32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_task_set_period(task as *mut lv_task_t, period as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Make a lv_task ready. It will not wait its period."]
        #[doc = " - __`task`__: pointer to a lv_task."]
        pub fn task_ready(task: *mut lv_task_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Make a lv_task ready. It will not wait its period."]
                #[doc = " - __`task`__: pointer to a lv_task."]
                pub fn lv_task_ready(task: *mut lv_task_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_task_ready(task as *mut lv_task_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Delete the lv_task after one call"]
        #[doc = " - __`task`__: pointer to a lv_task."]
        pub fn task_once(task: *mut lv_task_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Delete the lv_task after one call"]
                #[doc = " - __`task`__: pointer to a lv_task."]
                pub fn lv_task_once(task: *mut lv_task_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_task_once(task as *mut lv_task_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Reset a lv_task."]
        #[doc =
          " It will be called the previously set period milliseconds later."]
        #[doc = " - __`task`__: pointer to a lv_task."]
        pub fn task_reset(task: *mut lv_task_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Reset a lv_task."]
                #[doc =
                  " It will be called the previously set period milliseconds later."]
                #[doc = " - __`task`__: pointer to a lv_task."]
                pub fn lv_task_reset(task: *mut lv_task_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_task_reset(task as *mut lv_task_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Enable or disable the whole  lv_task handling"]
        #[doc =
          " - __`en:`__: true: lv_task handling is running, false: lv_task handling is suspended"]
        pub fn task_enable(en: bool) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Enable or disable the whole  lv_task handling"]
                #[doc =
                  " - __`en:`__: true: lv_task handling is running, false: lv_task handling is suspended"]
                pub fn lv_task_enable(en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_task_enable(en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get idle percentage"]
        #[doc = " Return: the lv_task idle in percentage"]
        pub fn task_get_idle() -> LvglResult<u8> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get idle percentage"]
                #[doc = " Return: the lv_task idle in percentage"]
                pub fn lv_task_get_idle()
                -> u8;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_task_get_idle();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Structure for holding display buffer information."]
        #[repr(C)]
        pub struct lv_disp_buf_t {
            #[doc = "< First display buffer."]
            pub buf1: *mut ::cty::c_void,
            #[doc = "< Second display buffer."]
            pub buf2: *mut ::cty::c_void,
            pub buf_act: *mut ::cty::c_void,
            pub size: u32,
            pub area: lv_area_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 3usize],
        }
        impl Default for lv_disp_buf_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_disp_buf_t {
            #[inline]
            pub fn flushing(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_flushing(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(flushing: u32)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let flushing: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(flushing)
                                                    };
                                                flushing as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Display Driver structure to be registered by HAL"]
        #[repr(C)]
        pub struct _disp_drv_t {
            #[doc = "< Horizontal resolution."]
            pub hor_res: lv_coord_t,
            #[doc = "< Vertical resolution."]
            pub ver_res: lv_coord_t,
            #[doc =
              " Pointer to a buffer initialized with `lv_disp_buf_init()`."]
            #[doc =
              " LittlevGL will use this buffer(s) to draw the screens contents"]
            pub buffer: *mut lv_disp_buf_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            #[doc =
              " MANDATORY: Write the internal buffer (VDB) to the display. 'lv_disp_flush_ready()' has to be"]
            #[doc = " called when finished"]
            pub flush_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                          *mut _disp_drv_t,
                                                                      area:
                                                                          *const lv_area_t,
                                                                      color_p:
                                                                          *mut lv_color_t)>,
            #[doc =
              " OPTIONAL: Extend the invalidated areas to match with the display drivers requirements"]
            #[doc = " E.g. round `y` to, 8, 16 ..) on a monochrome display"]
            pub rounder_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                            *mut _disp_drv_t,
                                                                        area:
                                                                            *mut lv_area_t)>,
            #[doc =
              " OPTIONAL: Set a pixel in a buffer according to the special requirements of the display"]
            #[doc =
              " Can be used for color format not supported in LittelvGL. E.g. 2 bit -> 4 gray scales"]
            #[doc =
              " __Note:__ Much slower then drawing with supported color formats."]
            pub set_px_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                           *mut _disp_drv_t,
                                                                       buf:
                                                                           *mut u8,
                                                                       buf_w:
                                                                           lv_coord_t,
                                                                       x:
                                                                           lv_coord_t,
                                                                       y:
                                                                           lv_coord_t,
                                                                       color:
                                                                           lv_color_t,
                                                                       opa:
                                                                           lv_opa_t)>,
            #[doc =
              " OPTIONAL: Called after every refresh cycle to tell the rendering and flushing time + the"]
            #[doc = " number of flushed pixels"]
            pub monitor_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                            *mut _disp_drv_t,
                                                                        time:
                                                                            u32,
                                                                        px:
                                                                            u32)>,
            #[doc = " On CHROMA_KEYED images this color will be transparent."]
            #[doc = " `LV_COLOR_TRANSP` by default. (lv_conf.h)"]
            pub color_chroma_key: lv_color_t,
            #[doc = "< Custom display driver user data"]
            pub user_data: lv_disp_drv_user_data_t,
        }
        impl Default for _disp_drv_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _disp_drv_t {
            #[inline]
            pub fn antialiasing(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_antialiasing(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn rotated(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_rotated(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(antialiasing: u32, rotated: u32)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let antialiasing: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(antialiasing)
                                                    };
                                                antialiasing as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let rotated: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(rotated)
                                                    };
                                                rotated as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_disp_drv_t = _disp_drv_t;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct _disp_t {
            pub driver: lv_disp_drv_t,
            pub refr_task: *mut lv_task_t,
            #[doc = " Screens of the display"]
            pub scr_ll: lv_ll_t,
            #[doc = "< Currently active screen on this display"]
            pub act_scr: *mut _lv_obj_t,
            #[doc = "< @see lv_disp_get_layer_top"]
            pub top_layer: *mut _lv_obj_t,
            #[doc = "< @see lv_disp_get_layer_sys"]
            pub sys_layer: *mut _lv_obj_t,
            #[doc = " Invalidated (marked to redraw) areas"]
            pub inv_areas: [lv_area_t; 32usize],
            pub inv_area_joined: [u8; 32usize],
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
            #[doc = "< 0 when rendering down, 1 when rendering up"]
            pub render_direction: ::cty::c_int,
            #[doc = "< Last time there was activity on this display"]
            pub last_activity_time: u32,
        }
        impl Default for _disp_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _disp_t {
            #[inline]
            pub fn inv_p(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_inv_p(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 10u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(inv_p: u32)
             -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u16> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 10u8,
                                            {
                                                let inv_p: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(inv_p)
                                                    };
                                                inv_p as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_disp_t = _disp_t;
        #[doc = " Initialize a display driver with default values."]
        #[doc =
          " It is used to have known values in the fields and not junk in memory."]
        #[doc = " After it you can safely set only the fields you need."]
        #[doc = " - __`driver`__: pointer to driver variable to initialize"]
        pub fn disp_drv_init(driver: *mut lv_disp_drv_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Initialize a display driver with default values."]
                #[doc =
                  " It is used to have known values in the fields and not junk in memory."]
                #[doc =
                  " After it you can safely set only the fields you need."]
                #[doc =
                  " - __`driver`__: pointer to driver variable to initialize"]
                pub fn lv_disp_drv_init(driver: *mut lv_disp_drv_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_disp_drv_init(driver as *mut lv_disp_drv_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Initialize a display buffer"]
        #[doc =
          " - __`disp_buf`__: pointer `lv_disp_buf_t` variable to initialize"]
        #[doc =
          " - __`buf1`__: A buffer to be used by LittlevGL to draw the image."]
        #[doc = "             Always has to specified and can't be NULL."]
        #[doc =
          "             Can be an array allocated by the user. E.g. `static lv_color_t disp_buf1[1024 * 10]`"]
        #[doc = "             Or a memory address e.g. in external SRAM"]
        #[doc =
          " - __`buf2`__: Optionally specify a second buffer to make image rendering and image flushing"]
        #[doc = "             (sending to the display) parallel."]
        #[doc =
          "             In the `disp_drv->flush` you should use DMA or similar hardware to send"]
        #[doc = "             the image to the display in the background."]
        #[doc =
          "             It lets LittlevGL to render next frame into the other buffer while previous is being"]
        #[doc = " sent. Set to `NULL` if unused."]
        #[doc =
          " - __`size_in_px_cnt`__: size of the `buf1` and `buf2` in pixel count."]
        pub fn disp_buf_init(disp_buf: *mut lv_disp_buf_t, buf1: Ptr,
                             buf2: Ptr, size_in_px_cnt: u32)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Initialize a display buffer"]
                #[doc =
                  " - __`disp_buf`__: pointer `lv_disp_buf_t` variable to initialize"]
                #[doc =
                  " - __`buf1`__: A buffer to be used by LittlevGL to draw the image."]
                #[doc =
                  "             Always has to specified and can't be NULL."]
                #[doc =
                  "             Can be an array allocated by the user. E.g. `static lv_color_t disp_buf1[1024 * 10]`"]
                #[doc =
                  "             Or a memory address e.g. in external SRAM"]
                #[doc =
                  " - __`buf2`__: Optionally specify a second buffer to make image rendering and image flushing"]
                #[doc = "             (sending to the display) parallel."]
                #[doc =
                  "             In the `disp_drv->flush` you should use DMA or similar hardware to send"]
                #[doc =
                  "             the image to the display in the background."]
                #[doc =
                  "             It lets LittlevGL to render next frame into the other buffer while previous is being"]
                #[doc = " sent. Set to `NULL` if unused."]
                #[doc =
                  " - __`size_in_px_cnt`__: size of the `buf1` and `buf2` in pixel count."]
                pub fn lv_disp_buf_init(disp_buf: *mut lv_disp_buf_t,
                                        buf1: *mut ::cty::c_void,
                                        buf2: *mut ::cty::c_void,
                                        size_in_px_cnt: u32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_disp_buf_init(disp_buf as *mut lv_disp_buf_t,
                                 buf1 as *mut ::cty::c_void,
                                 buf2 as *mut ::cty::c_void,
                                 size_in_px_cnt as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Register an initialized display driver."]
        #[doc = " Automatically set the first display as active."]
        #[doc =
          " - __`driver`__: pointer to an initialized 'lv_disp_drv_t' variable (can be local variable)"]
        #[doc = " Return: pointer to the new display or NULL on error"]
        pub fn disp_drv_register(driver: *mut lv_disp_drv_t)
         -> LvglResult<*mut lv_disp_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Register an initialized display driver."]
                #[doc = " Automatically set the first display as active."]
                #[doc =
                  " - __`driver`__: pointer to an initialized 'lv_disp_drv_t' variable (can be local variable)"]
                #[doc =
                  " Return: pointer to the new display or NULL on error"]
                pub fn lv_disp_drv_register(driver: *mut lv_disp_drv_t)
                -> *mut lv_disp_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_disp_drv_register(driver as *mut lv_disp_drv_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Update the driver in run time."]
        #[doc =
          " - __`disp`__: pointer to a display. (return value of `lv_disp_drv_register`)"]
        #[doc = " - __`new_drv`__: pointer to the new driver"]
        pub fn disp_drv_update(disp: *mut lv_disp_t,
                               new_drv: *mut lv_disp_drv_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Update the driver in run time."]
                #[doc =
                  " - __`disp`__: pointer to a display. (return value of `lv_disp_drv_register`)"]
                #[doc = " - __`new_drv`__: pointer to the new driver"]
                pub fn lv_disp_drv_update(disp: *mut lv_disp_t,
                                          new_drv: *mut lv_disp_drv_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_disp_drv_update(disp as *mut lv_disp_t,
                                   new_drv as *mut lv_disp_drv_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Remove a display"]
        #[doc = " - __`disp`__: pointer to display"]
        pub fn disp_remove(disp: *mut lv_disp_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Remove a display"]
                #[doc = " - __`disp`__: pointer to display"]
                pub fn lv_disp_remove(disp: *mut lv_disp_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_disp_remove(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set a default screen. The new screens will be created on it by default."]
        #[doc = " - __`disp`__: pointer to a display"]
        pub fn disp_set_default(disp: *mut lv_disp_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set a default screen. The new screens will be created on it by default."]
                #[doc = " - __`disp`__: pointer to a display"]
                pub fn lv_disp_set_default(disp: *mut lv_disp_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_disp_set_default(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the default display"]
        #[doc = " Return: pointer to the default display"]
        pub fn disp_get_default() -> LvglResult<*mut lv_disp_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the default display"]
                #[doc = " Return: pointer to the default display"]
                pub fn lv_disp_get_default()
                -> *mut lv_disp_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_disp_get_default();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the horizontal resolution of a display"]
        #[doc =
          " - __`disp`__: pointer to a display (NULL to use the default display)"]
        #[doc = " Return: the horizontal resolution of the display"]
        pub fn disp_get_hor_res(disp: *mut lv_disp_t)
         -> LvglResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the horizontal resolution of a display"]
                #[doc =
                  " - __`disp`__: pointer to a display (NULL to use the default display)"]
                #[doc = " Return: the horizontal resolution of the display"]
                pub fn lv_disp_get_hor_res(disp: *mut lv_disp_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_disp_get_hor_res(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the vertical resolution of a display"]
        #[doc =
          " - __`disp`__: pointer to a display (NULL to use the default display)"]
        #[doc = " Return: the vertical resolution of the display"]
        pub fn disp_get_ver_res(disp: *mut lv_disp_t)
         -> LvglResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the vertical resolution of a display"]
                #[doc =
                  " - __`disp`__: pointer to a display (NULL to use the default display)"]
                #[doc = " Return: the vertical resolution of the display"]
                pub fn lv_disp_get_ver_res(disp: *mut lv_disp_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_disp_get_ver_res(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get if anti-aliasing is enabled for a display or not"]
        #[doc =
          " - __`disp`__: pointer to a display (NULL to use the default display)"]
        #[doc = " Return: true: anti-aliasing is enabled; false: disabled"]
        pub fn disp_get_antialiasing(disp: *mut lv_disp_t)
         -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get if anti-aliasing is enabled for a display or not"]
                #[doc =
                  " - __`disp`__: pointer to a display (NULL to use the default display)"]
                #[doc =
                  " Return: true: anti-aliasing is enabled; false: disabled"]
                pub fn lv_disp_get_antialiasing(disp: *mut lv_disp_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_disp_get_antialiasing(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn disp_set_direction(disp: *mut lv_disp_t,
                                  direction: ::cty::c_int) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_disp_set_direction(disp: *mut lv_disp_t,
                                             direction: ::cty::c_int);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_disp_set_direction(disp as *mut lv_disp_t,
                                      direction as ::cty::c_int);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Call in the display driver's `flush_cb` function when the flushing is finished"]
        #[doc =
          " - __`disp_drv`__: pointer to display driver in `flush_cb` where this function is called"]
        pub fn disp_flush_ready(disp_drv: *mut lv_disp_drv_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Call in the display driver's `flush_cb` function when the flushing is finished"]
                #[doc =
                  " - __`disp_drv`__: pointer to display driver in `flush_cb` where this function is called"]
                pub fn lv_disp_flush_ready(disp_drv: *mut lv_disp_drv_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_disp_flush_ready(disp_drv as *mut lv_disp_drv_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the next display."]
        #[doc =
          " - __`disp`__: pointer to the current display. NULL to initialize."]
        #[doc =
          " Return: the next display or NULL if no more. Give the first display when the parameter is NULL"]
        pub fn disp_get_next(disp: *mut lv_disp_t)
         -> LvglResult<*mut lv_disp_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the next display."]
                #[doc =
                  " - __`disp`__: pointer to the current display. NULL to initialize."]
                #[doc =
                  " Return: the next display or NULL if no more. Give the first display when the parameter is NULL"]
                pub fn lv_disp_get_next(disp: *mut lv_disp_t)
                -> *mut lv_disp_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_disp_get_next(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the internal buffer of a display"]
        #[doc = " - __`disp`__: pointer to a display"]
        #[doc = " Return: pointer to the internal buffers"]
        pub fn disp_get_buf(disp: *mut lv_disp_t)
         -> LvglResult<*mut lv_disp_buf_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the internal buffer of a display"]
                #[doc = " - __`disp`__: pointer to a display"]
                #[doc = " Return: pointer to the internal buffers"]
                pub fn lv_disp_get_buf(disp: *mut lv_disp_t)
                -> *mut lv_disp_buf_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_disp_get_buf(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the number of areas in the buffer"]
        #[doc = " Return: number of invalid areas"]
        pub fn disp_get_inv_buf_size(disp: *mut lv_disp_t)
         -> LvglResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the number of areas in the buffer"]
                #[doc = " Return: number of invalid areas"]
                pub fn lv_disp_get_inv_buf_size(disp: *mut lv_disp_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_disp_get_inv_buf_size(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Pop (delete) the last 'num' invalidated areas from the buffer"]
        #[doc = " - __`num`__: number of areas to delete"]
        pub fn disp_pop_from_inv_buf(disp: *mut lv_disp_t, num: u16)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Pop (delete) the last 'num' invalidated areas from the buffer"]
                #[doc = " - __`num`__: number of areas to delete"]
                pub fn lv_disp_pop_from_inv_buf(disp: *mut lv_disp_t,
                                                num: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_disp_pop_from_inv_buf(disp as *mut lv_disp_t, num as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Check the driver configuration if it's double buffered (both `buf1` and `buf2` are set)"]
        #[doc = " - __`disp`__: pointer to to display to check"]
        #[doc = " Return: true: double buffered; false: not double buffered"]
        pub fn disp_is_double_buf(disp: *mut lv_disp_t) -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Check the driver configuration if it's double buffered (both `buf1` and `buf2` are set)"]
                #[doc = " - __`disp`__: pointer to to display to check"]
                #[doc =
                  " Return: true: double buffered; false: not double buffered"]
                pub fn lv_disp_is_double_buf(disp: *mut lv_disp_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_disp_is_double_buf(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Check the driver configuration if it's TRUE double buffered (both `buf1` and `buf2` are set and"]
        #[doc = " `size` is screen sized)"]
        #[doc = " - __`disp`__: pointer to to display to check"]
        #[doc = " Return: true: double buffered; false: not double buffered"]
        pub fn disp_is_true_double_buf(disp: *mut lv_disp_t)
         -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Check the driver configuration if it's TRUE double buffered (both `buf1` and `buf2` are set and"]
                #[doc = " `size` is screen sized)"]
                #[doc = " - __`disp`__: pointer to to display to check"]
                #[doc =
                  " Return: true: double buffered; false: not double buffered"]
                pub fn lv_disp_is_true_double_buf(disp: *mut lv_disp_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_disp_is_true_double_buf(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = "< Uninitialized state"]
        pub const LV_INDEV_TYPE_NONE: _bindgen_ty_10 = 0;
        #[doc = "< Touch pad, mouse, external button"]
        pub const LV_INDEV_TYPE_POINTER: _bindgen_ty_10 = 1;
        #[doc = "< Keypad or keyboard"]
        pub const LV_INDEV_TYPE_KEYPAD: _bindgen_ty_10 = 2;
        #[doc =
          "< External (hardware button) which is assigned to a specific point of the"]
        #[doc = "screen"]
        pub const LV_INDEV_TYPE_BUTTON: _bindgen_ty_10 = 3;
        #[doc = "< Encoder with only Left, Right turn and a Button"]
        pub const LV_INDEV_TYPE_ENCODER: _bindgen_ty_10 = 4;
        #[doc = " Possible input device types"]
        pub type _bindgen_ty_10 = u8;
        pub type lv_indev_type_t = u8;
        pub const LV_INDEV_STATE_REL: _bindgen_ty_11 = 0;
        pub const LV_INDEV_STATE_PR: _bindgen_ty_11 = 1;
        #[doc = " States for input devices"]
        pub type _bindgen_ty_11 = u8;
        pub type lv_indev_state_t = u8;
        #[doc = " Data structure passed to an input driver to fill"]
        #[repr(C)]
        pub struct lv_indev_data_t {
            #[doc = "< For LV_INDEV_TYPE_POINTER the currently pressed point"]
            pub point: lv_point_t,
            #[doc = "< For LV_INDEV_TYPE_KEYPAD the currently pressed key"]
            pub key: u32,
            #[doc = "< For LV_INDEV_TYPE_BUTTON the currently pressed button"]
            pub btn_id: u32,
            #[doc =
              "< For LV_INDEV_TYPE_ENCODER number of steps since the previous read"]
            pub enc_diff: i16,
            #[doc = "< LV_INDEV_STATE_REL or LV_INDEV_STATE_PR"]
            pub state: lv_indev_state_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_indev_data_t {
            #[inline]
            fn default() -> lv_indev_data_t {
                lv_indev_data_t{point: ::core::default::Default::default(),
                                key: ::core::default::Default::default(),
                                btn_id: ::core::default::Default::default(),
                                enc_diff: ::core::default::Default::default(),
                                state: ::core::default::Default::default(),}
            }
        }
        #[doc = " Initialized by the user and registered by 'lv_indev_add()'"]
        #[repr(C)]
        pub struct _lv_indev_drv_t {
            pub type_: lv_indev_type_t,
            pub read_cb: ::core::option::Option<unsafe extern "C" fn(indev_drv:
                                                                         *mut _lv_indev_drv_t,
                                                                     data:
                                                                         *mut lv_indev_data_t)
                                                    -> bool>,
            #[doc = " Called when an action happened on the input device."]
            #[doc = " The second parameter is the event from `lv_event_t`"]
            pub feedback_cb: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                             *mut _lv_indev_drv_t,
                                                                         arg2:
                                                                             u8)>,
            pub user_data: lv_indev_drv_user_data_t,
            pub disp: *mut _disp_t,
            pub read_task: *mut lv_task_t,
            pub drag_limit: u8,
            pub drag_throw: u8,
            pub long_press_time: u16,
            pub long_press_rep_time: u16,
        }
        impl Default for _lv_indev_drv_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_indev_drv_t = _lv_indev_drv_t;
        #[doc = " Run time data of input devices"]
        #[doc =
          " Internally used by the library, you should not need to touch it."]
        #[repr(C)]
        pub struct _lv_indev_proc_t {
            #[doc = "< Current state of the input device."]
            pub state: lv_indev_state_t,
            pub types: _lv_indev_proc_t__bindgen_ty_1,
            #[doc = "< Pressed time stamp"]
            pub pr_timestamp: u32,
            #[doc = "< Long press repeat time stamp"]
            pub longpr_rep_timestamp: u32,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        #[repr(C)]
        pub struct _lv_indev_proc_t__bindgen_ty_1 {
            pub pointer: __BindgenUnionField<_lv_indev_proc_t__bindgen_ty_1__bindgen_ty_1>,
            pub keypad: __BindgenUnionField<_lv_indev_proc_t__bindgen_ty_1__bindgen_ty_2>,
            pub bindgen_union_field: [u64; 7usize],
        }
        #[repr(C)]
        pub struct _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_1 {
            #[doc = "< Current point of input device."]
            pub act_point: lv_point_t,
            #[doc = "< Last point of input device."]
            pub last_point: lv_point_t,
            #[doc = "< Difference between `act_point` and `last_point`."]
            pub vect: lv_point_t,
            pub drag_sum: lv_point_t,
            pub drag_throw_vect: lv_point_t,
            pub act_obj: *mut _lv_obj_t,
            pub last_obj: *mut _lv_obj_t,
            pub last_pressed: *mut _lv_obj_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_1 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_1 {
            #[inline]
            pub fn drag_limit_out(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_limit_out(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag_in_prog(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_in_prog(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(drag_limit_out: u8, drag_in_prog: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let drag_limit_out: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_limit_out)
                                                    };
                                                drag_limit_out as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let drag_in_prog: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_in_prog)
                                                    };
                                                drag_in_prog as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[repr(C)]
        pub struct _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_2 {
            pub last_state: lv_indev_state_t,
            pub last_key: u32,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for
         _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_2 {
            #[inline]
            fn default() -> _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_2 {
                _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_2{last_state:
                                                                 ::core::default::Default::default(),
                                                             last_key:
                                                                 ::core::default::Default::default(),}
            }
        }
        impl Default for _lv_indev_proc_t__bindgen_ty_1 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl Default for _lv_indev_proc_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_indev_proc_t {
            #[inline]
            pub fn long_pr_sent(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_long_pr_sent(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn reset_query(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_reset_query(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn disabled(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_disabled(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wait_until_release(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_wait_until_release(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(long_pr_sent: u8, reset_query: u8,
                                  disabled: u8, wait_until_release: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let long_pr_sent: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(long_pr_sent)
                                                    };
                                                long_pr_sent as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let reset_query: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(reset_query)
                                                    };
                                                reset_query as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let disabled: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(disabled)
                                                    };
                                                disabled as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let wait_until_release: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(wait_until_release)
                                                    };
                                                wait_until_release as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_indev_proc_t = _lv_indev_proc_t;
        #[repr(C)]
        pub struct _lv_group_t {
            _unused: [u8; 0],
        }
        #[doc =
          " The main input device descriptor with driver, runtime data ('proc') and some additional"]
        #[doc = " information"]
        #[repr(C)]
        pub struct _lv_indev_t {
            pub driver: lv_indev_drv_t,
            pub proc_: lv_indev_proc_t,
            #[doc = "< Cursor for LV_INPUT_TYPE_POINTER"]
            pub cursor: *mut _lv_obj_t,
            #[doc = "< Keypad destination group"]
            pub group: *mut _lv_group_t,
            #[doc =
              "< Array points assigned to the button ()screen will be pressed"]
            #[doc = "here by the buttons"]
            pub btn_points: *const lv_point_t,
        }
        impl Default for _lv_indev_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_indev_t = _lv_indev_t;
        #[doc = " Initialize an input device driver with default values."]
        #[doc =
          " It is used to surly have known values in the fields ant not memory junk."]
        #[doc = " After it you can set the fields."]
        #[doc = " - __`driver`__: pointer to driver variable to initialize"]
        pub fn indev_drv_init(driver: *mut lv_indev_drv_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Initialize an input device driver with default values."]
                #[doc =
                  " It is used to surly have known values in the fields ant not memory junk."]
                #[doc = " After it you can set the fields."]
                #[doc =
                  " - __`driver`__: pointer to driver variable to initialize"]
                pub fn lv_indev_drv_init(driver: *mut lv_indev_drv_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_indev_drv_init(driver as *mut lv_indev_drv_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Register an initialized input device driver."]
        #[doc =
          " - __`driver`__: pointer to an initialized 'lv_indev_drv_t' variable (can be local variable)"]
        #[doc = " Return: pointer to the new input device or NULL on error"]
        pub fn indev_drv_register(driver: *mut lv_indev_drv_t)
         -> LvglResult<*mut lv_indev_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Register an initialized input device driver."]
                #[doc =
                  " - __`driver`__: pointer to an initialized 'lv_indev_drv_t' variable (can be local variable)"]
                #[doc =
                  " Return: pointer to the new input device or NULL on error"]
                pub fn lv_indev_drv_register(driver: *mut lv_indev_drv_t)
                -> *mut lv_indev_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_indev_drv_register(driver as *mut lv_indev_drv_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Update the driver in run time."]
        #[doc =
          " - __`indev`__: pointer to a input device. (return value of `lv_indev_drv_register`)"]
        #[doc = " - __`new_drv`__: pointer to the new driver"]
        pub fn indev_drv_update(indev: *mut lv_indev_t,
                                new_drv: *mut lv_indev_drv_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Update the driver in run time."]
                #[doc =
                  " - __`indev`__: pointer to a input device. (return value of `lv_indev_drv_register`)"]
                #[doc = " - __`new_drv`__: pointer to the new driver"]
                pub fn lv_indev_drv_update(indev: *mut lv_indev_t,
                                           new_drv: *mut lv_indev_drv_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_indev_drv_update(indev as *mut lv_indev_t,
                                    new_drv as *mut lv_indev_drv_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the next input device."]
        #[doc =
          " - __`indev`__: pointer to the current input device. NULL to initialize."]
        #[doc =
          " Return: the next input devise or NULL if no more. Give the first input device when the parameter"]
        #[doc = " is NULL"]
        pub fn indev_get_next(indev: *mut lv_indev_t)
         -> LvglResult<*mut lv_indev_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the next input device."]
                #[doc =
                  " - __`indev`__: pointer to the current input device. NULL to initialize."]
                #[doc =
                  " Return: the next input devise or NULL if no more. Give the first input device when the parameter"]
                #[doc = " is NULL"]
                pub fn lv_indev_get_next(indev: *mut lv_indev_t)
                -> *mut lv_indev_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_indev_get_next(indev as *mut lv_indev_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Read data from an input device."]
        #[doc = " - __`indev`__: pointer to an input device"]
        #[doc = " - __`data`__: input device will write its data here"]
        #[doc =
          " Return: false: no more data; true: there more data to read (buffered)"]
        pub fn indev_read(indev: *mut lv_indev_t, data: *mut lv_indev_data_t)
         -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Read data from an input device."]
                #[doc = " - __`indev`__: pointer to an input device"]
                #[doc =
                  " - __`data`__: input device will write its data here"]
                #[doc =
                  " Return: false: no more data; true: there more data to read (buffered)"]
                pub fn lv_indev_read(indev: *mut lv_indev_t,
                                     data: *mut lv_indev_data_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_indev_read(indev as *mut lv_indev_t,
                                  data as *mut lv_indev_data_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " You have to call this function periodically"]
        #[doc =
          " - __`tick_period`__: the call period of this function in milliseconds"]
        pub fn tick_inc(tick_period: u32) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " You have to call this function periodically"]
                #[doc =
                  " - __`tick_period`__: the call period of this function in milliseconds"]
                pub fn lv_tick_inc(tick_period: u32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_tick_inc(tick_period as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the elapsed milliseconds since start up"]
        #[doc = " Return: the elapsed milliseconds"]
        pub fn tick_get() -> LvglResult<u32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the elapsed milliseconds since start up"]
                #[doc = " Return: the elapsed milliseconds"]
                pub fn lv_tick_get()
                -> u32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_tick_get();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the elapsed milliseconds since a previous time stamp"]
        #[doc =
          " - __`prev_tick`__: a previous time stamp (return value of systick_get() )"]
        #[doc = " Return: the elapsed milliseconds since 'prev_tick'"]
        pub fn tick_elaps(prev_tick: u32) -> LvglResult<u32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the elapsed milliseconds since a previous time stamp"]
                #[doc =
                  " - __`prev_tick`__: a previous time stamp (return value of systick_get() )"]
                #[doc = " Return: the elapsed milliseconds since 'prev_tick'"]
                pub fn lv_tick_elaps(prev_tick: u32)
                -> u32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_tick_elaps(prev_tick as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = "< Draw the main portion of the object"]
        pub const LV_DESIGN_DRAW_MAIN: _bindgen_ty_12 = 0;
        #[doc = "< Draw extras on the object"]
        pub const LV_DESIGN_DRAW_POST: _bindgen_ty_12 = 1;
        #[doc = "< Check if the object fully covers the 'mask_p' area"]
        pub const LV_DESIGN_COVER_CHK: _bindgen_ty_12 = 2;
        #[doc = " Design modes"]
        pub type _bindgen_ty_12 = u8;
        pub type lv_design_mode_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t
            =
            ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                        mask_p:
                                                            *const lv_area_t,
                                                        mode:
                                                            lv_design_mode_t)
                                       -> bool>;
        #[doc = "< The object has been pressed"]
        pub const LV_EVENT_PRESSED: _bindgen_ty_13 = 0;
        #[doc =
          "< The object is being pressed (called continuously while pressing)"]
        pub const LV_EVENT_PRESSING: _bindgen_ty_13 = 1;
        #[doc =
          "< User is still pressing but slid cursor/finger off of the object"]
        pub const LV_EVENT_PRESS_LOST: _bindgen_ty_13 = 2;
        #[doc =
          "< User pressed object for a short period of time, then released it. Not called if dragged."]
        pub const LV_EVENT_SHORT_CLICKED: _bindgen_ty_13 = 3;
        #[doc =
          "< Object has been pressed for at least `LV_INDEV_LONG_PRESS_TIME`.  Not called if dragged."]
        pub const LV_EVENT_LONG_PRESSED: _bindgen_ty_13 = 4;
        #[doc = "< Called after `LV_INDEV_LONG_PRESS_TIME` in every"]
        #[doc = "`LV_INDEV_LONG_PRESS_REP_TIME` ms.  Not called if dragged."]
        pub const LV_EVENT_LONG_PRESSED_REPEAT: _bindgen_ty_13 = 5;
        #[doc =
          "< Called on release if not dragged (regardless to long press)"]
        pub const LV_EVENT_CLICKED: _bindgen_ty_13 = 6;
        #[doc = "< Called in every cases when the object has been released"]
        pub const LV_EVENT_RELEASED: _bindgen_ty_13 = 7;
        pub const LV_EVENT_DRAG_BEGIN: _bindgen_ty_13 = 8;
        pub const LV_EVENT_DRAG_END: _bindgen_ty_13 = 9;
        pub const LV_EVENT_DRAG_THROW_BEGIN: _bindgen_ty_13 = 10;
        pub const LV_EVENT_KEY: _bindgen_ty_13 = 11;
        pub const LV_EVENT_FOCUSED: _bindgen_ty_13 = 12;
        pub const LV_EVENT_DEFOCUSED: _bindgen_ty_13 = 13;
        #[doc = "< The object's value has changed (i.e. slider moved)"]
        pub const LV_EVENT_VALUE_CHANGED: _bindgen_ty_13 = 14;
        pub const LV_EVENT_INSERT: _bindgen_ty_13 = 15;
        pub const LV_EVENT_REFRESH: _bindgen_ty_13 = 16;
        #[doc = "< \"Ok\", \"Apply\" or similar specific button has clicked"]
        pub const LV_EVENT_APPLY: _bindgen_ty_13 = 17;
        #[doc =
          "< \"Close\", \"Cancel\" or similar specific button has clicked"]
        pub const LV_EVENT_CANCEL: _bindgen_ty_13 = 18;
        #[doc = "< Object is being deleted"]
        pub const LV_EVENT_DELETE: _bindgen_ty_13 = 19;
        pub type _bindgen_ty_13 = u8;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t
            =
            ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                        event: lv_event_t)>;
        #[doc = "< Object is being deleted"]
        pub const LV_SIGNAL_CLEANUP: _bindgen_ty_14 = 0;
        #[doc = "< Child was removed/added"]
        pub const LV_SIGNAL_CHILD_CHG: _bindgen_ty_14 = 1;
        #[doc = "< Object coordinates/size have changed"]
        pub const LV_SIGNAL_CORD_CHG: _bindgen_ty_14 = 2;
        #[doc = "< Parent's size has changed"]
        pub const LV_SIGNAL_PARENT_SIZE_CHG: _bindgen_ty_14 = 3;
        #[doc = "< Object's style has changed"]
        pub const LV_SIGNAL_STYLE_CHG: _bindgen_ty_14 = 4;
        #[doc = "<The base dir has changed"]
        pub const LV_SIGNAL_BASE_DIR_CHG: _bindgen_ty_14 = 5;
        #[doc = "< Object's extra padding has changed"]
        pub const LV_SIGNAL_REFR_EXT_DRAW_PAD: _bindgen_ty_14 = 6;
        #[doc = "< LittlevGL needs to retrieve the object's type"]
        pub const LV_SIGNAL_GET_TYPE: _bindgen_ty_14 = 7;
        #[doc = "< The object has been pressed"]
        pub const LV_SIGNAL_PRESSED: _bindgen_ty_14 = 8;
        #[doc =
          "< The object is being pressed (called continuously while pressing)"]
        pub const LV_SIGNAL_PRESSING: _bindgen_ty_14 = 9;
        #[doc =
          "< User is still pressing but slid cursor/finger off of the object"]
        pub const LV_SIGNAL_PRESS_LOST: _bindgen_ty_14 = 10;
        #[doc =
          "< User pressed object for a short period of time, then released it. Not called if dragged."]
        pub const LV_SIGNAL_RELEASED: _bindgen_ty_14 = 11;
        #[doc =
          "< Object has been pressed for at least `LV_INDEV_LONG_PRESS_TIME`.  Not called if dragged."]
        pub const LV_SIGNAL_LONG_PRESS: _bindgen_ty_14 = 12;
        #[doc =
          "< Called after `LV_INDEV_LONG_PRESS_TIME` in every `LV_INDEV_LONG_PRESS_REP_TIME` ms.  Not called if dragged."]
        pub const LV_SIGNAL_LONG_PRESS_REP: _bindgen_ty_14 = 13;
        pub const LV_SIGNAL_DRAG_BEGIN: _bindgen_ty_14 = 14;
        pub const LV_SIGNAL_DRAG_END: _bindgen_ty_14 = 15;
        pub const LV_SIGNAL_FOCUS: _bindgen_ty_14 = 16;
        pub const LV_SIGNAL_DEFOCUS: _bindgen_ty_14 = 17;
        pub const LV_SIGNAL_CONTROL: _bindgen_ty_14 = 18;
        pub const LV_SIGNAL_GET_EDITABLE: _bindgen_ty_14 = 19;
        #[doc =
          " Signals are for use by the object itself or to extend the object's functionality."]
        #[doc =
          " Applications should use ::lv_obj_set_event_cb to be notified of events that occur"]
        #[doc = " on the object."]
        pub type _bindgen_ty_14 = u8;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t
            =
            ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                        sign: lv_signal_t,
                                                        param:
                                                            *mut ::cty::c_void)
                                       -> lv_res_t>;
        pub const LV_ALIGN_CENTER: _bindgen_ty_15 = 0;
        pub const LV_ALIGN_IN_TOP_LEFT: _bindgen_ty_15 = 1;
        pub const LV_ALIGN_IN_TOP_MID: _bindgen_ty_15 = 2;
        pub const LV_ALIGN_IN_TOP_RIGHT: _bindgen_ty_15 = 3;
        pub const LV_ALIGN_IN_BOTTOM_LEFT: _bindgen_ty_15 = 4;
        pub const LV_ALIGN_IN_BOTTOM_MID: _bindgen_ty_15 = 5;
        pub const LV_ALIGN_IN_BOTTOM_RIGHT: _bindgen_ty_15 = 6;
        pub const LV_ALIGN_IN_LEFT_MID: _bindgen_ty_15 = 7;
        pub const LV_ALIGN_IN_RIGHT_MID: _bindgen_ty_15 = 8;
        pub const LV_ALIGN_OUT_TOP_LEFT: _bindgen_ty_15 = 9;
        pub const LV_ALIGN_OUT_TOP_MID: _bindgen_ty_15 = 10;
        pub const LV_ALIGN_OUT_TOP_RIGHT: _bindgen_ty_15 = 11;
        pub const LV_ALIGN_OUT_BOTTOM_LEFT: _bindgen_ty_15 = 12;
        pub const LV_ALIGN_OUT_BOTTOM_MID: _bindgen_ty_15 = 13;
        pub const LV_ALIGN_OUT_BOTTOM_RIGHT: _bindgen_ty_15 = 14;
        pub const LV_ALIGN_OUT_LEFT_TOP: _bindgen_ty_15 = 15;
        pub const LV_ALIGN_OUT_LEFT_MID: _bindgen_ty_15 = 16;
        pub const LV_ALIGN_OUT_LEFT_BOTTOM: _bindgen_ty_15 = 17;
        pub const LV_ALIGN_OUT_RIGHT_TOP: _bindgen_ty_15 = 18;
        pub const LV_ALIGN_OUT_RIGHT_MID: _bindgen_ty_15 = 19;
        pub const LV_ALIGN_OUT_RIGHT_BOTTOM: _bindgen_ty_15 = 20;
        #[doc = " Object alignment."]
        pub type _bindgen_ty_15 = u8;
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_reailgn_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_reailgn_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_reailgn_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn origo_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_origo_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, origo_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let origo_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(origo_align)
                                                    };
                                                origo_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = "< Object can be dragged horizontally."]
        pub const LV_DRAG_DIR_HOR: _bindgen_ty_16 = 1;
        #[doc = "< Object can be dragged vertically."]
        pub const LV_DRAG_DIR_VER: _bindgen_ty_16 = 2;
        #[doc = "< Object can be dragged in all directions."]
        pub const LV_DRAG_DIR_ALL: _bindgen_ty_16 = 3;
        pub type _bindgen_ty_16 = u8;
        pub type lv_drag_dir_t = u8;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct _lv_obj_t {
            #[doc = "< Pointer to the parent object"]
            pub par: *mut _lv_obj_t,
            #[doc = "< Linked list to store the children objects"]
            pub child_ll: lv_ll_t,
            #[doc = "< Coordinates of the object (x1, y1, x2, y2)"]
            pub coords: lv_area_t,
            #[doc = "< Event callback function"]
            pub event_cb: lv_event_cb_t,
            #[doc = "< Object type specific signal function"]
            pub signal_cb: lv_signal_cb_t,
            #[doc = "< Object type specific design function"]
            pub design_cb: lv_design_cb_t,
            #[doc = "< Object type specific extended data"]
            pub ext_attr: *mut ::cty::c_void,
            #[doc = "< Pointer to the object's style"]
            pub style_p: *const lv_style_t,
            #[doc = "< Pointer to the group of the object"]
            pub group_p: *mut ::cty::c_void,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
            #[doc =
              "< Automatically happening actions can be prevented. 'OR'ed values from"]
            #[doc = "`lv_protect_t`"]
            pub protect: u8,
            #[doc =
              "< Scale down the opacity by this factor. Effects all children as well"]
            pub opa_scale: lv_opa_t,
            #[doc = "< EXTtend the size in every direction for drawing."]
            pub ext_draw_pad: lv_coord_t,
            #[doc = "< Information about the last call to ::lv_obj_align."]
            pub realign: lv_reailgn_t,
            #[doc = "< Custom user data for object."]
            pub user_data: lv_obj_user_data_t,
        }
        impl Default for _lv_obj_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_obj_t {
            #[inline]
            pub fn click(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_click(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag_throw(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_throw(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag_parent(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_parent(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn hidden(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_hidden(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn top(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_top(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(5usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_en(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_opa_scale_en(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn parent_event(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_parent_event(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag_dir(&self) -> lv_drag_dir_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_dir(&mut self, val: lv_drag_dir_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn base_dir(&self) -> lv_bidi_dir_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_base_dir(&mut self, val: lv_bidi_dir_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn reserved(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_reserved(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(click: u8, drag: u8, drag_throw: u8,
                                  drag_parent: u8, hidden: u8, top: u8,
                                  opa_scale_en: u8, parent_event: u8,
                                  drag_dir: lv_drag_dir_t,
                                  base_dir: lv_bidi_dir_t, reserved: u8)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let click: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(click)
                                                    };
                                                click as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let drag: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag)
                                                    };
                                                drag as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let drag_throw: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_throw)
                                                    };
                                                drag_throw as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let drag_parent: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_parent)
                                                    };
                                                drag_parent as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 1u8,
                                            {
                                                let hidden: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(hidden)
                                                    };
                                                hidden as u64
                                            });
                __bindgen_bitfield_unit.set(5usize, 1u8,
                                            {
                                                let top: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(top)
                                                    };
                                                top as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let opa_scale_en: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_en)
                                                    };
                                                opa_scale_en as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let parent_event: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(parent_event)
                                                    };
                                                parent_event as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 2u8,
                                            {
                                                let drag_dir: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_dir)
                                                    };
                                                drag_dir as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 2u8,
                                            {
                                                let base_dir: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(base_dir)
                                                    };
                                                base_dir as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 3u8,
                                            {
                                                let reserved: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(reserved)
                                                    };
                                                reserved as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_obj_t = _lv_obj_t;
        pub const LV_PROTECT_NONE: _bindgen_ty_17 = 0;
        #[doc = "< Disable the child change signal. Used by the library"]
        pub const LV_PROTECT_CHILD_CHG: _bindgen_ty_17 = 1;
        #[doc = "< Prevent automatic parent change (e.g. in lv_page)"]
        pub const LV_PROTECT_PARENT: _bindgen_ty_17 = 2;
        #[doc = "< Prevent automatic positioning (e.g. in lv_cont layout)"]
        pub const LV_PROTECT_POS: _bindgen_ty_17 = 4;
        #[doc =
          "< Prevent the object be followed in automatic ordering (e.g. in"]
        #[doc = "lv_cont PRETTY layout)"]
        pub const LV_PROTECT_FOLLOW: _bindgen_ty_17 = 8;
        #[doc =
          "< If the `indev` was pressing this object but swiped out while"]
        #[doc = "pressing do not search other object."]
        pub const LV_PROTECT_PRESS_LOST: _bindgen_ty_17 = 16;
        #[doc = "< Prevent focusing the object by clicking on it"]
        pub const LV_PROTECT_CLICK_FOCUS: _bindgen_ty_17 = 32;
        pub type _bindgen_ty_17 = u8;
        pub type lv_protect_t = u8;
        #[doc =
          " Used by `lv_obj_get_type()`. The object's and its ancestor types are stored here"]
        #[repr(C)]
        pub struct lv_obj_type_t {
            #[doc =
              "< [0]: the actual type, [1]: ancestor, [2] #1's ancestor"]
            #[doc = "... [x]: \"lv_obj\""]
            pub type_: [*const ::cty::c_char; 8usize],
        }
        impl Default for lv_obj_type_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = " Init. the 'lv' library."]
        pub fn lv_init() -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Init. the 'lv' library."]
                pub fn lv_init();
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_init();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Create a basic object"]
        #[doc = " - __`parent`__: pointer to a parent object."]
        #[doc = "                  If NULL then a screen will be created"]
        #[doc =
          " - __`copy`__: pointer to a base object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the new object"]
        pub fn create(parent: *mut lv_obj_t, copy: *const lv_obj_t)
         -> LvglResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a basic object"]
                #[doc = " - __`parent`__: pointer to a parent object."]
                #[doc =
                  "                  If NULL then a screen will be created"]
                #[doc =
                  " - __`copy`__: pointer to a base object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the new object"]
                pub fn lv_obj_create(parent: *mut lv_obj_t,
                                     copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_create(parent as *mut lv_obj_t,
                                  copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Delete 'obj' and all of its children"]
        #[doc = " - __`obj`__: pointer to an object to delete"]
        #[doc = " Return: LV_RES_INV because the object is deleted"]
        pub fn del(obj: *mut lv_obj_t) -> LvglResult<lv_res_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Delete 'obj' and all of its children"]
                #[doc = " - __`obj`__: pointer to an object to delete"]
                #[doc = " Return: LV_RES_INV because the object is deleted"]
                pub fn lv_obj_del(obj: *mut lv_obj_t)
                -> lv_res_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_del(obj as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Helper function for asynchronously deleting objects."]
        #[doc =
          " Useful for cases where you can't delete an object directly in an `LV_EVENT_DELETE` handler (i.e. parent)."]
        #[doc = " - __`obj`__: object to delete"]
        #[doc = " @see lv_async_call"]
        pub fn del_async(obj: *mut _lv_obj_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Helper function for asynchronously deleting objects."]
                #[doc =
                  " Useful for cases where you can't delete an object directly in an `LV_EVENT_DELETE` handler (i.e. parent)."]
                #[doc = " - __`obj`__: object to delete"]
                #[doc = " @see lv_async_call"]
                pub fn lv_obj_del_async(obj: *mut _lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_del_async(obj as *mut _lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Delete all children of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        pub fn clean(obj: *mut lv_obj_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Delete all children of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                pub fn lv_obj_clean(obj: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_clean(obj as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Mark the object as invalid therefore its current position will be redrawn by 'lv_refr_task'"]
        #[doc = " - __`obj`__: pointer to an object"]
        pub fn invalidate(obj: *const lv_obj_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Mark the object as invalid therefore its current position will be redrawn by 'lv_refr_task'"]
                #[doc = " - __`obj`__: pointer to an object"]
                pub fn lv_obj_invalidate(obj: *const lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_invalidate(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set a new parent for an object. Its relative position will be the same."]
        #[doc = " - __`obj`__: pointer to an object. Can't be a screen."]
        #[doc =
          " - __`parent`__: pointer to the new parent object. (Can't be NULL)"]
        pub fn set_parent(obj: *mut lv_obj_t, parent: *mut lv_obj_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set a new parent for an object. Its relative position will be the same."]
                #[doc =
                  " - __`obj`__: pointer to an object. Can't be a screen."]
                #[doc =
                  " - __`parent`__: pointer to the new parent object. (Can't be NULL)"]
                pub fn lv_obj_set_parent(obj: *mut lv_obj_t,
                                         parent: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_parent(obj as *mut lv_obj_t,
                                  parent as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Move and object to the foreground"]
        #[doc = " - __`obj`__: pointer to an object"]
        pub fn move_foreground(obj: *mut lv_obj_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Move and object to the foreground"]
                #[doc = " - __`obj`__: pointer to an object"]
                pub fn lv_obj_move_foreground(obj: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_move_foreground(obj as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Move and object to the background"]
        #[doc = " - __`obj`__: pointer to an object"]
        pub fn move_background(obj: *mut lv_obj_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Move and object to the background"]
                #[doc = " - __`obj`__: pointer to an object"]
                pub fn lv_obj_move_background(obj: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_move_background(obj as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set relative the position of an object (relative to the parent)"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`x`__: new distance from the left side of the parent"]
        #[doc = " - __`y`__: new distance from the top of the parent"]
        pub fn set_pos(obj: *mut lv_obj_t, x: lv_coord_t, y: lv_coord_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set relative the position of an object (relative to the parent)"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`x`__: new distance from the left side of the parent"]
                #[doc = " - __`y`__: new distance from the top of the parent"]
                pub fn lv_obj_set_pos(obj: *mut lv_obj_t, x: lv_coord_t,
                                      y: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_pos(obj as *mut lv_obj_t, x as lv_coord_t,
                               y as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the x coordinate of a object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`x`__: new distance from the left side from the parent"]
        pub fn set_x(obj: *mut lv_obj_t, x: lv_coord_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the x coordinate of a object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`x`__: new distance from the left side from the parent"]
                pub fn lv_obj_set_x(obj: *mut lv_obj_t, x: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_x(obj as *mut lv_obj_t, x as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the y coordinate of a object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`y`__: new distance from the top of the parent"]
        pub fn set_y(obj: *mut lv_obj_t, y: lv_coord_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the y coordinate of a object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`y`__: new distance from the top of the parent"]
                pub fn lv_obj_set_y(obj: *mut lv_obj_t, y: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_y(obj as *mut lv_obj_t, y as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the size of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`w`__: new width"]
        #[doc = " - __`h`__: new height"]
        pub fn set_size(obj: *mut lv_obj_t, w: lv_coord_t, h: lv_coord_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the size of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`w`__: new width"]
                #[doc = " - __`h`__: new height"]
                pub fn lv_obj_set_size(obj: *mut lv_obj_t, w: lv_coord_t,
                                       h: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_size(obj as *mut lv_obj_t, w as lv_coord_t,
                                h as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the width of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`w`__: new width"]
        pub fn set_width(obj: *mut lv_obj_t, w: lv_coord_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the width of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`w`__: new width"]
                pub fn lv_obj_set_width(obj: *mut lv_obj_t, w: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_width(obj as *mut lv_obj_t, w as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the height of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`h`__: new height"]
        pub fn set_height(obj: *mut lv_obj_t, h: lv_coord_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the height of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`h`__: new height"]
                pub fn lv_obj_set_height(obj: *mut lv_obj_t, h: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_height(obj as *mut lv_obj_t, h as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Align an object to an other object."]
        #[doc = " - __`obj`__: pointer to an object to align"]
        #[doc =
          " - __`base`__: pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
        #[doc = " - __`align`__: type of alignment (see 'lv_align_t' enum)"]
        #[doc = " - __`x_mod`__: x coordinate shift after alignment"]
        #[doc = " - __`y_mod`__: y coordinate shift after alignment"]
        pub fn align(obj: *mut lv_obj_t, base: *const lv_obj_t,
                     align: lv_align_t, x_mod: lv_coord_t, y_mod: lv_coord_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Align an object to an other object."]
                #[doc = " - __`obj`__: pointer to an object to align"]
                #[doc =
                  " - __`base`__: pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
                #[doc =
                  " - __`align`__: type of alignment (see 'lv_align_t' enum)"]
                #[doc = " - __`x_mod`__: x coordinate shift after alignment"]
                #[doc = " - __`y_mod`__: y coordinate shift after alignment"]
                pub fn lv_obj_align(obj: *mut lv_obj_t, base: *const lv_obj_t,
                                    align: lv_align_t, x_mod: lv_coord_t,
                                    y_mod: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_align(obj as *mut lv_obj_t, base as *const lv_obj_t,
                             align as lv_align_t, x_mod as lv_coord_t,
                             y_mod as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Align an object to an other object."]
        #[doc = " - __`obj`__: pointer to an object to align"]
        #[doc =
          " - __`base`__: pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
        #[doc = " - __`align`__: type of alignment (see 'lv_align_t' enum)"]
        #[doc = " - __`x_mod`__: x coordinate shift after alignment"]
        #[doc = " - __`y_mod`__: y coordinate shift after alignment"]
        pub fn align_origo(obj: *mut lv_obj_t, base: *const lv_obj_t,
                           align: lv_align_t, x_mod: lv_coord_t,
                           y_mod: lv_coord_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Align an object to an other object."]
                #[doc = " - __`obj`__: pointer to an object to align"]
                #[doc =
                  " - __`base`__: pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
                #[doc =
                  " - __`align`__: type of alignment (see 'lv_align_t' enum)"]
                #[doc = " - __`x_mod`__: x coordinate shift after alignment"]
                #[doc = " - __`y_mod`__: y coordinate shift after alignment"]
                pub fn lv_obj_align_origo(obj: *mut lv_obj_t,
                                          base: *const lv_obj_t,
                                          align: lv_align_t,
                                          x_mod: lv_coord_t,
                                          y_mod: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_align_origo(obj as *mut lv_obj_t,
                                   base as *const lv_obj_t,
                                   align as lv_align_t, x_mod as lv_coord_t,
                                   y_mod as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Realign the object based on the last `lv_obj_align` parameters."]
        #[doc = " - __`obj`__: pointer to an object"]
        pub fn realign(obj: *mut lv_obj_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Realign the object based on the last `lv_obj_align` parameters."]
                #[doc = " - __`obj`__: pointer to an object"]
                pub fn lv_obj_realign(obj: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_realign(obj as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Enable the automatic realign of the object when its size has changed based on the last"]
        #[doc = " `lv_obj_align` parameters."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " - __`en`__: true: enable auto realign; false: disable auto realign"]
        pub fn set_auto_realign(obj: *mut lv_obj_t, en: bool)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Enable the automatic realign of the object when its size has changed based on the last"]
                #[doc = " `lv_obj_align` parameters."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`en`__: true: enable auto realign; false: disable auto realign"]
                pub fn lv_obj_set_auto_realign(obj: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_auto_realign(obj as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the size of an extended clickable area"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`left`__: extended clickable are on the left [px]"]
        #[doc = " - __`right`__: extended clickable are on the right [px]"]
        #[doc = " - __`top`__: extended clickable are on the top [px]"]
        #[doc = " - __`bottom`__: extended clickable are on the bottom [px]"]
        pub fn set_ext_click_area(obj: *mut lv_obj_t, left: lv_coord_t,
                                  right: lv_coord_t, top: lv_coord_t,
                                  bottom: lv_coord_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the size of an extended clickable area"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`left`__: extended clickable are on the left [px]"]
                #[doc =
                  " - __`right`__: extended clickable are on the right [px]"]
                #[doc =
                  " - __`top`__: extended clickable are on the top [px]"]
                #[doc =
                  " - __`bottom`__: extended clickable are on the bottom [px]"]
                pub fn lv_obj_set_ext_click_area(obj: *mut lv_obj_t,
                                                 left: lv_coord_t,
                                                 right: lv_coord_t,
                                                 top: lv_coord_t,
                                                 bottom: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_ext_click_area(obj as *mut lv_obj_t,
                                          left as lv_coord_t,
                                          right as lv_coord_t,
                                          top as lv_coord_t,
                                          bottom as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set a new style for an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`style_p`__: pointer to the new style"]
        pub fn set_style(obj: *mut lv_obj_t, style: *const lv_style_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a new style for an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`style_p`__: pointer to the new style"]
                pub fn lv_obj_set_style(obj: *mut lv_obj_t,
                                        style: *const lv_style_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style(obj as *mut lv_obj_t,
                                 style as *const lv_style_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Notify an object about its style is modified"]
        #[doc = " - __`obj`__: pointer to an object"]
        pub fn refresh_style(obj: *mut lv_obj_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Notify an object about its style is modified"]
                #[doc = " - __`obj`__: pointer to an object"]
                pub fn lv_obj_refresh_style(obj: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_refresh_style(obj as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Notify all object if a style is modified"]
        #[doc =
          " - __`style`__: pointer to a style. Only the objects with this style will be notified"]
        #[doc = "               (NULL to notify all objects)"]
        pub fn report_style_mod(style: *mut lv_style_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Notify all object if a style is modified"]
                #[doc =
                  " - __`style`__: pointer to a style. Only the objects with this style will be notified"]
                #[doc = "               (NULL to notify all objects)"]
                pub fn lv_obj_report_style_mod(style: *mut lv_style_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_report_style_mod(style as *mut lv_style_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Hide an object. It won't be visible and clickable."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`en`__: true: hide the object"]
        pub fn set_hidden(obj: *mut lv_obj_t, en: bool) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Hide an object. It won't be visible and clickable."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`en`__: true: hide the object"]
                pub fn lv_obj_set_hidden(obj: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_hidden(obj as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Enable or disable the clicking of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`en`__: true: make the object clickable"]
        pub fn set_click(obj: *mut lv_obj_t, en: bool) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Enable or disable the clicking of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`en`__: true: make the object clickable"]
                pub fn lv_obj_set_click(obj: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_click(obj as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Enable to bring this object to the foreground if it"]
        #[doc = " or any of its children is clicked"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`en`__: true: enable the auto top feature"]
        pub fn set_top(obj: *mut lv_obj_t, en: bool) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Enable to bring this object to the foreground if it"]
                #[doc = " or any of its children is clicked"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`en`__: true: enable the auto top feature"]
                pub fn lv_obj_set_top(obj: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_top(obj as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Enable the dragging of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`en`__: true: make the object dragable"]
        pub fn set_drag(obj: *mut lv_obj_t, en: bool) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Enable the dragging of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`en`__: true: make the object dragable"]
                pub fn lv_obj_set_drag(obj: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_drag(obj as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the directions an object can be dragged in"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`drag_dir`__: bitwise OR of allowed drag directions"]
        pub fn set_drag_dir(obj: *mut lv_obj_t, drag_dir: lv_drag_dir_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the directions an object can be dragged in"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`drag_dir`__: bitwise OR of allowed drag directions"]
                pub fn lv_obj_set_drag_dir(obj: *mut lv_obj_t,
                                           drag_dir: lv_drag_dir_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_drag_dir(obj as *mut lv_obj_t,
                                    drag_dir as lv_drag_dir_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Enable the throwing of an object after is is dragged"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`en`__: true: enable the drag throw"]
        pub fn set_drag_throw(obj: *mut lv_obj_t, en: bool)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Enable the throwing of an object after is is dragged"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`en`__: true: enable the drag throw"]
                pub fn lv_obj_set_drag_throw(obj: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_drag_throw(obj as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Enable to use parent for drag related operations."]
        #[doc =
          " If trying to drag the object the parent will be moved instead"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`en`__: true: enable the 'drag parent' for the object"]
        pub fn set_drag_parent(obj: *mut lv_obj_t, en: bool)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Enable to use parent for drag related operations."]
                #[doc =
                  " If trying to drag the object the parent will be moved instead"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`en`__: true: enable the 'drag parent' for the object"]
                pub fn lv_obj_set_drag_parent(obj: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_drag_parent(obj as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Propagate the events to the parent too"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`en`__: true: enable the event propagation"]
        pub fn set_parent_event(obj: *mut lv_obj_t, en: bool)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Propagate the events to the parent too"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`en`__: true: enable the event propagation"]
                pub fn lv_obj_set_parent_event(obj: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_parent_event(obj as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn set_base_dir(obj: *mut lv_obj_t, dir: lv_bidi_dir_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_base_dir(obj: *mut lv_obj_t,
                                           dir: lv_bidi_dir_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_base_dir(obj as *mut lv_obj_t,
                                    dir as lv_bidi_dir_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the opa scale enable parameter (required to set opa_scale with `lv_obj_set_opa_scale()`)"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " - __`en`__: true: opa scaling is enabled for this object and all children; false: no opa scaling"]
        pub fn set_opa_scale_enable(obj: *mut lv_obj_t, en: bool)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the opa scale enable parameter (required to set opa_scale with `lv_obj_set_opa_scale()`)"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`en`__: true: opa scaling is enabled for this object and all children; false: no opa scaling"]
                pub fn lv_obj_set_opa_scale_enable(obj: *mut lv_obj_t,
                                                   en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_opa_scale_enable(obj as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the opa scale of an object."]
        #[doc =
          " The opacity of this object and all it's children will be scaled down with this factor."]
        #[doc =
          " `lv_obj_set_opa_scale_enable(obj, true)` needs to be called to enable it."]
        #[doc =
          " (not for all children just for the parent where to start the opa scaling)"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`opa_scale`__: a factor to scale down opacity [0..255]"]
        pub fn set_opa_scale(obj: *mut lv_obj_t, opa_scale: lv_opa_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the opa scale of an object."]
                #[doc =
                  " The opacity of this object and all it's children will be scaled down with this factor."]
                #[doc =
                  " `lv_obj_set_opa_scale_enable(obj, true)` needs to be called to enable it."]
                #[doc =
                  " (not for all children just for the parent where to start the opa scaling)"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`opa_scale`__: a factor to scale down opacity [0..255]"]
                pub fn lv_obj_set_opa_scale(obj: *mut lv_obj_t,
                                            opa_scale: lv_opa_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_opa_scale(obj as *mut lv_obj_t,
                                     opa_scale as lv_opa_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set a bit or bits in the protect filed"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`prot`__: 'OR'-ed values from `lv_protect_t`"]
        pub fn set_protect(obj: *mut lv_obj_t, prot: u8) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a bit or bits in the protect filed"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`prot`__: 'OR'-ed values from `lv_protect_t`"]
                pub fn lv_obj_set_protect(obj: *mut lv_obj_t, prot: u8);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_protect(obj as *mut lv_obj_t, prot as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Clear a bit or bits in the protect filed"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`prot`__: 'OR'-ed values from `lv_protect_t`"]
        pub fn clear_protect(obj: *mut lv_obj_t, prot: u8) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Clear a bit or bits in the protect filed"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`prot`__: 'OR'-ed values from `lv_protect_t`"]
                pub fn lv_obj_clear_protect(obj: *mut lv_obj_t, prot: u8);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_clear_protect(obj as *mut lv_obj_t, prot as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set a an event handler function for an object."]
        #[doc =
          " Used by the user to react on event which happens with the object."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`event_cb`__: the new event function"]
        pub fn set_event_cb(obj: *mut lv_obj_t, event_cb: lv_event_cb_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a an event handler function for an object."]
                #[doc =
                  " Used by the user to react on event which happens with the object."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`event_cb`__: the new event function"]
                pub fn lv_obj_set_event_cb(obj: *mut lv_obj_t,
                                           event_cb: lv_event_cb_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_event_cb(obj as *mut lv_obj_t,
                                    event_cb as lv_event_cb_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Send an event to the object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`event`__: the type of the event from `lv_event_t`."]
        #[doc =
          " - __`data`__: arbitrary data depending on the object type and the event. (Usually `NULL`)"]
        #[doc =
          " Return: LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event"]
        pub fn event_send(obj: *mut lv_obj_t, event: lv_event_t,
                          data: *const ::cty::c_void)
         -> LvglResult<lv_res_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Send an event to the object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`event`__: the type of the event from `lv_event_t`."]
                #[doc =
                  " - __`data`__: arbitrary data depending on the object type and the event. (Usually `NULL`)"]
                #[doc =
                  " Return: LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event"]
                pub fn lv_event_send(obj: *mut lv_obj_t, event: lv_event_t,
                                     data: *const ::cty::c_void)
                -> lv_res_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_event_send(obj as *mut lv_obj_t, event as lv_event_t,
                                  data as *const ::cty::c_void);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Call an event function with an object, event, and data."]
        #[doc =
          " - __`event_xcb`__: an event callback function. If `NULL` `LV_RES_OK` will return without any actions."]
        #[doc =
          "        (the 'x' in the argument name indicates that its not a fully generic function because it not follows"]
        #[doc = "         the `func_name(object, callback, ...)` convention)"]
        #[doc =
          " - __`obj`__: pointer to an object to associate with the event (can be `NULL` to simply call the `event_cb`)"]
        #[doc = " - __`event`__: an event"]
        #[doc = " - __`data`__: pointer to a custom data"]
        #[doc =
          " Return: LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event"]
        pub fn event_send_func(event_xcb: lv_event_cb_t, obj: *mut lv_obj_t,
                               event: lv_event_t, data: *const ::cty::c_void)
         -> LvglResult<lv_res_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Call an event function with an object, event, and data."]
                #[doc =
                  " - __`event_xcb`__: an event callback function. If `NULL` `LV_RES_OK` will return without any actions."]
                #[doc =
                  "        (the 'x' in the argument name indicates that its not a fully generic function because it not follows"]
                #[doc =
                  "         the `func_name(object, callback, ...)` convention)"]
                #[doc =
                  " - __`obj`__: pointer to an object to associate with the event (can be `NULL` to simply call the `event_cb`)"]
                #[doc = " - __`event`__: an event"]
                #[doc = " - __`data`__: pointer to a custom data"]
                #[doc =
                  " Return: LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event"]
                pub fn lv_event_send_func(event_xcb: lv_event_cb_t,
                                          obj: *mut lv_obj_t,
                                          event: lv_event_t,
                                          data: *const ::cty::c_void)
                -> lv_res_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_event_send_func(event_xcb as lv_event_cb_t,
                                       obj as *mut lv_obj_t,
                                       event as lv_event_t,
                                       data as *const ::cty::c_void);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the `data` parameter of the current event"]
        #[doc = " Return: the `data` parameter"]
        pub fn event_get_data() -> LvglResult<*const ::cty::c_void> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the `data` parameter of the current event"]
                #[doc = " Return: the `data` parameter"]
                pub fn lv_event_get_data()
                -> *const ::cty::c_void;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_event_get_data();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Set the a signal function of an object. Used internally by the library."]
        #[doc = " Always call the previous signal function in the new."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`signal_cb`__: the new signal function"]
        pub fn set_signal_cb(obj: *mut lv_obj_t, signal_cb: lv_signal_cb_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the a signal function of an object. Used internally by the library."]
                #[doc =
                  " Always call the previous signal function in the new."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`signal_cb`__: the new signal function"]
                pub fn lv_obj_set_signal_cb(obj: *mut lv_obj_t,
                                            signal_cb: lv_signal_cb_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_signal_cb(obj as *mut lv_obj_t,
                                     signal_cb as lv_signal_cb_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Send an event to the object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`event`__: the type of the event from `lv_event_t`."]
        pub fn signal_send(obj: *mut lv_obj_t, signal: lv_signal_t,
                           param: Ptr) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Send an event to the object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`event`__: the type of the event from `lv_event_t`."]
                pub fn lv_signal_send(obj: *mut lv_obj_t, signal: lv_signal_t,
                                      param: *mut ::cty::c_void);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_signal_send(obj as *mut lv_obj_t, signal as lv_signal_t,
                               param as *mut ::cty::c_void);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set a new design function for an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`design_cb`__: the new design function"]
        pub fn set_design_cb(obj: *mut lv_obj_t, design_cb: lv_design_cb_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a new design function for an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`design_cb`__: the new design function"]
                pub fn lv_obj_set_design_cb(obj: *mut lv_obj_t,
                                            design_cb: lv_design_cb_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_design_cb(obj as *mut lv_obj_t,
                                     design_cb as lv_design_cb_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Allocate a new ext. data for an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`ext_size`__: the size of the new ext. data"]
        #[doc = " Return: pointer to the allocated ext"]
        pub fn allocate_ext_attr(obj: *mut lv_obj_t, ext_size: u16)
         -> LvglResult<*mut ::cty::c_void> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Allocate a new ext. data for an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`ext_size`__: the size of the new ext. data"]
                #[doc = " Return: pointer to the allocated ext"]
                pub fn lv_obj_allocate_ext_attr(obj: *mut lv_obj_t,
                                                ext_size: u16)
                -> *mut ::cty::c_void;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_allocate_ext_attr(obj as *mut lv_obj_t,
                                             ext_size as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Send a 'LV_SIGNAL_REFR_EXT_SIZE' signal to the object"]
        #[doc = " - __`obj`__: pointer to an object"]
        pub fn refresh_ext_draw_pad(obj: *mut lv_obj_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Send a 'LV_SIGNAL_REFR_EXT_SIZE' signal to the object"]
                #[doc = " - __`obj`__: pointer to an object"]
                pub fn lv_obj_refresh_ext_draw_pad(obj: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_refresh_ext_draw_pad(obj as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Return with the screen of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: pointer to a screen"]
        pub fn get_screen(obj: *const lv_obj_t) -> LvglResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Return with the screen of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: pointer to a screen"]
                pub fn lv_obj_get_screen(obj: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_screen(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the display of an object"]
        #[doc = " - __`scr`__: pointer to an object"]
        #[doc = " Return: pointer the object's display"]
        pub fn get_disp(obj: *const lv_obj_t) -> LvglResult<*mut lv_disp_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the display of an object"]
                #[doc = " - __`scr`__: pointer to an object"]
                #[doc = " Return: pointer the object's display"]
                pub fn lv_obj_get_disp(obj: *const lv_obj_t)
                -> *mut lv_disp_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_disp(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Returns with the parent of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: pointer to the parent of  'obj'"]
        pub fn get_parent(obj: *const lv_obj_t) -> LvglResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Returns with the parent of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: pointer to the parent of  'obj'"]
                pub fn lv_obj_get_parent(obj: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_parent(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Iterate through the children of an object (start from the \"youngest, lastly created\")"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`child`__: NULL at first call to get the next children"]
        #[doc = "                  and the previous return value later"]
        #[doc =
          " Return: the child after 'act_child' or NULL if no more child"]
        pub fn get_child(obj: *const lv_obj_t, child: *const lv_obj_t)
         -> LvglResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Iterate through the children of an object (start from the \"youngest, lastly created\")"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`child`__: NULL at first call to get the next children"]
                #[doc =
                  "                  and the previous return value later"]
                #[doc =
                  " Return: the child after 'act_child' or NULL if no more child"]
                pub fn lv_obj_get_child(obj: *const lv_obj_t,
                                        child: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_child(obj as *const lv_obj_t,
                                     child as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Iterate through the children of an object (start from the \"oldest\", firstly created)"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`child`__: NULL at first call to get the next children"]
        #[doc = "                  and the previous return value later"]
        #[doc =
          " Return: the child after 'act_child' or NULL if no more child"]
        pub fn get_child_back(obj: *const lv_obj_t, child: *const lv_obj_t)
         -> LvglResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Iterate through the children of an object (start from the \"oldest\", firstly created)"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`child`__: NULL at first call to get the next children"]
                #[doc =
                  "                  and the previous return value later"]
                #[doc =
                  " Return: the child after 'act_child' or NULL if no more child"]
                pub fn lv_obj_get_child_back(obj: *const lv_obj_t,
                                             child: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_child_back(obj as *const lv_obj_t,
                                          child as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Count the children of an object (only children directly on 'obj')"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: children number of 'obj'"]
        pub fn count_children(obj: *const lv_obj_t) -> LvglResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Count the children of an object (only children directly on 'obj')"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: children number of 'obj'"]
                pub fn lv_obj_count_children(obj: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_count_children(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Recursively count the children of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: children number of 'obj'"]
        pub fn count_children_recursive(obj: *const lv_obj_t)
         -> LvglResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Recursively count the children of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: children number of 'obj'"]
                pub fn lv_obj_count_children_recursive(obj: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_count_children_recursive(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Copy the coordinates of an object to an area"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " - __`cords_p`__: pointer to an area to store the coordinates"]
        pub fn get_coords(obj: *const lv_obj_t, cords_p: *mut lv_area_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Copy the coordinates of an object to an area"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`cords_p`__: pointer to an area to store the coordinates"]
                pub fn lv_obj_get_coords(obj: *const lv_obj_t,
                                         cords_p: *mut lv_area_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_get_coords(obj as *const lv_obj_t,
                                  cords_p as *mut lv_area_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Reduce area retried by `lv_obj_get_coords()` the get graphically usable area of an object."]
        #[doc =
          " (Without the size of the border or other extra graphical elements)"]
        #[doc = " - __`coords_p`__: store the result area here"]
        pub fn get_inner_coords(obj: *const lv_obj_t,
                                coords_p: *mut lv_area_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Reduce area retried by `lv_obj_get_coords()` the get graphically usable area of an object."]
                #[doc =
                  " (Without the size of the border or other extra graphical elements)"]
                #[doc = " - __`coords_p`__: store the result area here"]
                pub fn lv_obj_get_inner_coords(obj: *const lv_obj_t,
                                               coords_p: *mut lv_area_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_get_inner_coords(obj as *const lv_obj_t,
                                        coords_p as *mut lv_area_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the x coordinate of object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: distance of 'obj' from the left side of its parent"]
        pub fn get_x(obj: *const lv_obj_t) -> LvglResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the x coordinate of object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " Return: distance of 'obj' from the left side of its parent"]
                pub fn lv_obj_get_x(obj: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_x(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the y coordinate of object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: distance of 'obj' from the top of its parent"]
        pub fn get_y(obj: *const lv_obj_t) -> LvglResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the y coordinate of object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " Return: distance of 'obj' from the top of its parent"]
                pub fn lv_obj_get_y(obj: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_y(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the width of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the width"]
        pub fn get_width(obj: *const lv_obj_t) -> LvglResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the width of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the width"]
                pub fn lv_obj_get_width(obj: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_width(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the height of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the height"]
        pub fn get_height(obj: *const lv_obj_t) -> LvglResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the height of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the height"]
                pub fn lv_obj_get_height(obj: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_height(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get that width reduced by the left and right padding."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the width which still fits into the container"]
        pub fn get_width_fit(obj: *const lv_obj_t) -> LvglResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get that width reduced by the left and right padding."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " Return: the width which still fits into the container"]
                pub fn lv_obj_get_width_fit(obj: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_width_fit(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get that height reduced by the top an bottom padding."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the height which still fits into the container"]
        pub fn get_height_fit(obj: *const lv_obj_t)
         -> LvglResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get that height reduced by the top an bottom padding."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " Return: the height which still fits into the container"]
                pub fn lv_obj_get_height_fit(obj: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_height_fit(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the automatic realign property of the object."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " Return:  true: auto realign is enabled; false: auto realign is disabled"]
        pub fn get_auto_realign(obj: *const lv_obj_t) -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the automatic realign property of the object."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " Return:  true: auto realign is enabled; false: auto realign is disabled"]
                pub fn lv_obj_get_auto_realign(obj: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_auto_realign(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the left padding of extended clickable area"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the extended left padding"]
        pub fn get_ext_click_pad_left(obj: *const lv_obj_t)
         -> LvglResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the left padding of extended clickable area"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the extended left padding"]
                pub fn lv_obj_get_ext_click_pad_left(obj: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_ext_click_pad_left(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the right padding of extended clickable area"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the extended right padding"]
        pub fn get_ext_click_pad_right(obj: *const lv_obj_t)
         -> LvglResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the right padding of extended clickable area"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the extended right padding"]
                pub fn lv_obj_get_ext_click_pad_right(obj: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_ext_click_pad_right(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the top padding of extended clickable area"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the extended top padding"]
        pub fn get_ext_click_pad_top(obj: *const lv_obj_t)
         -> LvglResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the top padding of extended clickable area"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the extended top padding"]
                pub fn lv_obj_get_ext_click_pad_top(obj: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_ext_click_pad_top(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the bottom padding of extended clickable area"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the extended bottom padding"]
        pub fn get_ext_click_pad_bottom(obj: *const lv_obj_t)
         -> LvglResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the bottom padding of extended clickable area"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the extended bottom padding"]
                pub fn lv_obj_get_ext_click_pad_bottom(obj: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_ext_click_pad_bottom(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the extended size attribute of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the extended size attribute"]
        pub fn get_ext_draw_pad(obj: *const lv_obj_t)
         -> LvglResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the extended size attribute of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the extended size attribute"]
                pub fn lv_obj_get_ext_draw_pad(obj: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_ext_draw_pad(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get the style pointer of an object (if NULL get style of the parent)"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: pointer to a style"]
        pub fn get_style(obj: *const lv_obj_t)
         -> LvglResult<*const lv_style_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the style pointer of an object (if NULL get style of the parent)"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: pointer to a style"]
                pub fn lv_obj_get_style(obj: *const lv_obj_t)
                -> *const lv_style_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_style(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the hidden attribute of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: true: the object is hidden"]
        pub fn get_hidden(obj: *const lv_obj_t) -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the hidden attribute of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: true: the object is hidden"]
                pub fn lv_obj_get_hidden(obj: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_hidden(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the click enable attribute of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: true: the object is clickable"]
        pub fn get_click(obj: *const lv_obj_t) -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the click enable attribute of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: true: the object is clickable"]
                pub fn lv_obj_get_click(obj: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_click(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the top enable attribute of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: true: the auto top feature is enabled"]
        pub fn get_top(obj: *const lv_obj_t) -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the top enable attribute of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: true: the auto top feature is enabled"]
                pub fn lv_obj_get_top(obj: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_top(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the drag enable attribute of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: true: the object is dragable"]
        pub fn get_drag(obj: *const lv_obj_t) -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the drag enable attribute of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: true: the object is dragable"]
                pub fn lv_obj_get_drag(obj: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_drag(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the directions an object can be dragged"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " Return: bitwise OR of allowed directions an object can be dragged in"]
        pub fn get_drag_dir(obj: *const lv_obj_t)
         -> LvglResult<lv_drag_dir_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the directions an object can be dragged"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " Return: bitwise OR of allowed directions an object can be dragged in"]
                pub fn lv_obj_get_drag_dir(obj: *const lv_obj_t)
                -> lv_drag_dir_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_drag_dir(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the drag throw enable attribute of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: true: drag throw is enabled"]
        pub fn get_drag_throw(obj: *const lv_obj_t) -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the drag throw enable attribute of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: true: drag throw is enabled"]
                pub fn lv_obj_get_drag_throw(obj: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_drag_throw(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the drag parent attribute of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: true: drag parent is enabled"]
        pub fn get_drag_parent(obj: *const lv_obj_t) -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the drag parent attribute of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: true: drag parent is enabled"]
                pub fn lv_obj_get_drag_parent(obj: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_drag_parent(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the drag parent attribute of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: true: drag parent is enabled"]
        pub fn get_parent_event(obj: *const lv_obj_t) -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the drag parent attribute of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: true: drag parent is enabled"]
                pub fn lv_obj_get_parent_event(obj: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_parent_event(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn get_base_dir(obj: *const lv_obj_t)
         -> LvglResult<lv_bidi_dir_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_base_dir(obj: *const lv_obj_t)
                -> lv_bidi_dir_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_base_dir(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the opa scale enable parameter"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " Return: true: opa scaling is enabled for this object and all children; false: no opa scaling"]
        pub fn get_opa_scale_enable(obj: *const lv_obj_t)
         -> LvglResult<lv_opa_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the opa scale enable parameter"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " Return: true: opa scaling is enabled for this object and all children; false: no opa scaling"]
                pub fn lv_obj_get_opa_scale_enable(obj: *const lv_obj_t)
                -> lv_opa_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_opa_scale_enable(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the opa scale parameter of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: opa scale [0..255]"]
        pub fn get_opa_scale(obj: *const lv_obj_t) -> LvglResult<lv_opa_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the opa scale parameter of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: opa scale [0..255]"]
                pub fn lv_obj_get_opa_scale(obj: *const lv_obj_t)
                -> lv_opa_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_opa_scale(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the protect field of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: protect field ('OR'ed values of `lv_protect_t`)"]
        pub fn get_protect(obj: *const lv_obj_t) -> LvglResult<u8> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the protect field of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " Return: protect field ('OR'ed values of `lv_protect_t`)"]
                pub fn lv_obj_get_protect(obj: *const lv_obj_t)
                -> u8;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_protect(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Check at least one bit of a given protect bitfield is set"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " - __`prot`__: protect bits to test ('OR'ed values of `lv_protect_t`)"]
        #[doc =
          " Return: false: none of the given bits are set, true: at least one bit is set"]
        pub fn is_protected(obj: *const lv_obj_t, prot: u8)
         -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Check at least one bit of a given protect bitfield is set"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`prot`__: protect bits to test ('OR'ed values of `lv_protect_t`)"]
                #[doc =
                  " Return: false: none of the given bits are set, true: at least one bit is set"]
                pub fn lv_obj_is_protected(obj: *const lv_obj_t, prot: u8)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_is_protected(obj as *const lv_obj_t, prot as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the signal function of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the signal function"]
        pub fn get_signal_cb(obj: *const lv_obj_t)
         -> LvglResult<lv_signal_cb_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the signal function of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the signal function"]
                pub fn lv_obj_get_signal_cb(obj: *const lv_obj_t)
                -> lv_signal_cb_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_signal_cb(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the design function of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the design function"]
        pub fn get_design_cb(obj: *const lv_obj_t)
         -> LvglResult<lv_design_cb_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the design function of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the design function"]
                pub fn lv_obj_get_design_cb(obj: *const lv_obj_t)
                -> lv_design_cb_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_design_cb(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the event function of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the event function"]
        pub fn get_event_cb(obj: *const lv_obj_t)
         -> LvglResult<lv_event_cb_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the event function of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the event function"]
                pub fn lv_obj_get_event_cb(obj: *const lv_obj_t)
                -> lv_event_cb_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_event_cb(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the ext pointer"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the ext pointer but not the dynamic version"]
        #[doc = "         Use it as ext->data1, and NOT da(ext)->data1"]
        pub fn get_ext_attr(obj: *const lv_obj_t)
         -> LvglResult<*mut ::cty::c_void> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the ext pointer"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " Return: the ext pointer but not the dynamic version"]
                #[doc =
                  "         Use it as ext->data1, and NOT da(ext)->data1"]
                pub fn lv_obj_get_ext_attr(obj: *const lv_obj_t)
                -> *mut ::cty::c_void;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_ext_attr(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get object's and its ancestors type. Put their name in `type_buf` starting with the current type."]
        #[doc =
          " E.g. buf.type[0]=\"lv_btn\", buf.type[1]=\"lv_cont\", buf.type[2]=\"lv_obj\""]
        #[doc = " - __`obj`__: pointer to an object which type should be get"]
        #[doc =
          " - __`buf`__: pointer to an `lv_obj_type_t` buffer to store the types"]
        pub fn get_type(obj: *const lv_obj_t, buf: *mut lv_obj_type_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get object's and its ancestors type. Put their name in `type_buf` starting with the current type."]
                #[doc =
                  " E.g. buf.type[0]=\"lv_btn\", buf.type[1]=\"lv_cont\", buf.type[2]=\"lv_obj\""]
                #[doc =
                  " - __`obj`__: pointer to an object which type should be get"]
                #[doc =
                  " - __`buf`__: pointer to an `lv_obj_type_t` buffer to store the types"]
                pub fn lv_obj_get_type(obj: *const lv_obj_t,
                                       buf: *mut lv_obj_type_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_get_type(obj as *const lv_obj_t,
                                buf as *mut lv_obj_type_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the object's user data"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: user data"]
        pub fn get_user_data(obj: *const lv_obj_t)
         -> LvglResult<lv_obj_user_data_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the object's user data"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: user data"]
                pub fn lv_obj_get_user_data(obj: *const lv_obj_t)
                -> lv_obj_user_data_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_user_data(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get a pointer to the object's user data"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: pointer to the user data"]
        pub fn get_user_data_ptr(obj: *const lv_obj_t)
         -> LvglResult<*mut lv_obj_user_data_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get a pointer to the object's user data"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: pointer to the user data"]
                pub fn lv_obj_get_user_data_ptr(obj: *const lv_obj_t)
                -> *mut lv_obj_user_data_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_user_data_ptr(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set the object's user data. The data will be copied."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`data`__: user data"]
        pub fn set_user_data(obj: *mut lv_obj_t, data: lv_obj_user_data_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the object's user data. The data will be copied."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`data`__: user data"]
                pub fn lv_obj_set_user_data(obj: *mut lv_obj_t,
                                            data: lv_obj_user_data_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_user_data(obj as *mut lv_obj_t,
                                     data as lv_obj_user_data_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the group of the object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the pointer to group of the object"]
        pub fn get_group(obj: *const lv_obj_t)
         -> LvglResult<*mut ::cty::c_void> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the group of the object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the pointer to group of the object"]
                pub fn lv_obj_get_group(obj: *const lv_obj_t)
                -> *mut ::cty::c_void;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_group(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Tell whether the object is the focused object of a group or not."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " Return: true: the object is focused, false: the object is not focused or not in a group"]
        pub fn is_focused(obj: *const lv_obj_t) -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Tell whether the object is the focused object of a group or not."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " Return: true: the object is focused, false: the object is not focused or not in a group"]
                pub fn lv_obj_is_focused(obj: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_is_focused(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Used in the signal callback to handle `LV_SIGNAL_GET_TYPE` signal"]
        #[doc =
          " - __`buf`__: pointer to `lv_obj_type_t`. (`param` in the signal callback)"]
        #[doc =
          " - __`name`__: name of the object. E.g. \"lv_btn\". (Only the pointer is saved)"]
        #[doc = " Return: LV_RES_OK"]
        pub fn handle_get_type_signal(buf: *mut lv_obj_type_t, name: &Strn)
         -> LvglResult<lv_res_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Used in the signal callback to handle `LV_SIGNAL_GET_TYPE` signal"]
                #[doc =
                  " - __`buf`__: pointer to `lv_obj_type_t`. (`param` in the signal callback)"]
                #[doc =
                  " - __`name`__: name of the object. E.g. \"lv_btn\". (Only the pointer is saved)"]
                #[doc = " Return: LV_RES_OK"]
                pub fn lv_obj_handle_get_type_signal(buf: *mut lv_obj_type_t,
                                                     name:
                                                         *const ::cty::c_char)
                -> lv_res_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            name.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_handle_get_type_signal(buf as *mut lv_obj_type_t,
                                                  name.as_ptr() as
                                                      *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
}
#[allow(unused_imports)]
pub mod objx {
    //! LittlevGL (LVGL) Objx API for Rust
    use crate::{result::*, core::{obj::{_lv_obj_t, lv_obj_t, lv_style_t}},
                Out, Ptr, Strn};
    /// Contains Rust bindings for LittlevGL (LVGL) Objx API `lv_objx`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod label {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        #[repr(C)]
        pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
        impl <T> __BindgenUnionField<T> {
            #[inline]
            pub fn new() -> Self {
                __BindgenUnionField(::core::marker::PhantomData)
            }
            #[inline]
            pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
            #[inline]
            pub unsafe fn as_mut(&mut self) -> &mut T {
                ::core::mem::transmute(self)
            }
        }
        impl <T> ::core::default::Default for __BindgenUnionField<T> {
            #[inline]
            fn default() -> Self { Self::new() }
        }
        impl <T> ::core::clone::Clone for __BindgenUnionField<T> {
            #[inline]
            fn clone(&self) -> Self { Self::new() }
        }
        impl <T> ::core::marker::Copy for __BindgenUnionField<T> { }
        impl <T> ::core::fmt::Debug for __BindgenUnionField<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>)
             -> ::core::fmt::Result {
                fmt.write_str("__BindgenUnionField")
            }
        }
        impl <T> ::core::hash::Hash for __BindgenUnionField<T> {
            fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) { }
        }
        impl <T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
            fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
        }
        impl <T> ::core::cmp::Eq for __BindgenUnionField<T> { }
        pub const LV_LABEL_DEF_SCROLL_SPEED: u32 = 25;
        pub const LV_LABEL_WAIT_CHAR_COUNT: u32 = 3;
        pub const LV_LABEL_TEXT_SEL: u32 = 0;
        pub const LV_LABEL_LONG_TXT_HINT: u32 = 0;
        pub const LV_LABEL_DOT_NUM: u32 = 3;
        pub const LV_LABEL_POS_LAST: u32 = 65535;
        pub const LV_LABEL_TEXT_SEL_OFF: u32 = 65535;
        pub type lv_coord_t = i16;
        pub type lv_font_user_data_t = *mut ::cty::c_void;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        #[doc = " Describes the properties of a glyph."]
        #[repr(C)]
        pub struct lv_font_glyph_dsc_t {
            #[doc =
              "< The glyph needs this space. Draw the next glyph after this width. 8 bit integer, 4 bit fractional"]
            pub adv_w: u16,
            #[doc = "< Width of the glyph's bounding box"]
            pub box_w: u8,
            #[doc = "< Height of the glyph's bounding box"]
            pub box_h: u8,
            #[doc = "< x offset of the bounding box"]
            pub ofs_x: i8,
            #[doc = "< y offset of the bounding box"]
            pub ofs_y: i8,
            #[doc = "< Bit-per-pixel: 1, 2, 4, 8"]
            pub bpp: u8,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_font_glyph_dsc_t {
            #[inline]
            fn default() -> lv_font_glyph_dsc_t {
                lv_font_glyph_dsc_t{adv_w:
                                        ::core::default::Default::default(),
                                    box_w:
                                        ::core::default::Default::default(),
                                    box_h:
                                        ::core::default::Default::default(),
                                    ofs_x:
                                        ::core::default::Default::default(),
                                    ofs_y:
                                        ::core::default::Default::default(),
                                    bpp: ::core::default::Default::default(),}
            }
        }
        #[doc = " Describe the properties of a font"]
        #[repr(C)]
        pub struct _lv_font_struct {
            #[doc = " Get a glyph's  descriptor from a font"]
            pub get_glyph_dsc: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                               *const _lv_font_struct,
                                                                           arg2:
                                                                               *mut lv_font_glyph_dsc_t,
                                                                           letter:
                                                                               u32,
                                                                           letter_next:
                                                                               u32)
                                                          -> bool>,
            #[doc = " Get a glyph's bitmap from a font"]
            pub get_glyph_bitmap: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *const _lv_font_struct,
                                                                              arg2:
                                                                                  u32)
                                                             -> *const u8>,
            #[doc = "< The real line height where any text fits"]
            pub line_height: u8,
            #[doc = "< Base line measured from the top of the line_height"]
            pub base_line: u8,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            #[doc =
              "< Store implementation specific or run_time data or caching here"]
            pub dsc: *mut ::cty::c_void,
            #[doc = "< Custom user data for font."]
            pub user_data: lv_font_user_data_t,
        }
        impl Default for _lv_font_struct {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_font_struct {
            #[inline]
            pub fn subpx(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_subpx(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(subpx: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 2u8,
                                            {
                                                let subpx: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(subpx)
                                                    };
                                                subpx as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_font_t = _lv_font_struct;
        #[repr(C)]
        pub struct lv_color16_t {
            pub ch: __BindgenUnionField<lv_color16_t__bindgen_ty_1>,
            pub full: __BindgenUnionField<u16>,
            pub bindgen_union_field: u16,
        }
        #[repr(C)]
        #[repr(align (2))]
        pub struct lv_color16_t__bindgen_ty_1 {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_color16_t__bindgen_ty_1 {
            #[inline]
            fn default() -> lv_color16_t__bindgen_ty_1 {
                lv_color16_t__bindgen_ty_1{_bitfield_1:
                                               ::core::default::Default::default(),}
            }
        }
        impl lv_color16_t__bindgen_ty_1 {
            #[inline]
            pub fn green_h(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_h(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn red(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_red(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn blue(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_blue(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn green_l(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_l(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(green_h: u16, red: u16, blue: u16,
                                  green_l: u16)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 3u8,
                                            {
                                                let green_h: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_h)
                                                    };
                                                green_h as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 5u8,
                                            {
                                                let red: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(red)
                                                    };
                                                red as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 5u8,
                                            {
                                                let blue: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(blue)
                                                    };
                                                blue as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 3u8,
                                            {
                                                let green_l: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_l)
                                                    };
                                                green_l as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_color16_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_color_t = lv_color16_t;
        pub type lv_opa_t = u8;
        #[doc = " Represents a point on the screen."]
        #[repr(C)]
        pub struct lv_point_t {
            pub x: lv_coord_t,
            pub y: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_point_t {
            #[inline]
            fn default() -> lv_point_t {
                lv_point_t{x: ::core::default::Default::default(),
                           y: ::core::default::Default::default(),}
            }
        }
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_border_part_t = u8;
        pub type lv_shadow_type_t = u8;
        #[doc = " Object background."]
        #[repr(C)]
        pub struct lv_style_t__bindgen_ty_1 {
            #[doc = "< Object's main background color."]
            pub main_color: lv_color_t,
            #[doc =
              "< Second color. If not equal to `main_color` a gradient will be drawn for the background."]
            pub grad_color: lv_color_t,
            #[doc =
              "< Object's corner radius. You can use #LV_RADIUS_CIRCLE if you want to draw a circle."]
            pub radius: lv_coord_t,
            #[doc = "< Object's opacity (0-255)."]
            pub opa: lv_opa_t,
            pub border: lv_style_t__bindgen_ty_1__bindgen_ty_1,
            pub shadow: lv_style_t__bindgen_ty_1__bindgen_ty_2,
            pub padding: lv_style_t__bindgen_ty_1__bindgen_ty_3,
        }
        #[repr(C)]
        pub struct lv_style_t__bindgen_ty_1__bindgen_ty_1 {
            #[doc = "< Border color"]
            pub color: lv_color_t,
            #[doc = "< Border width"]
            pub width: lv_coord_t,
            #[doc = "< Which borders to draw"]
            pub part: lv_border_part_t,
            #[doc = "< Border opacity."]
            pub opa: lv_opa_t,
        }
        impl Default for lv_style_t__bindgen_ty_1__bindgen_ty_1 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[repr(C)]
        pub struct lv_style_t__bindgen_ty_1__bindgen_ty_2 {
            pub color: lv_color_t,
            pub width: lv_coord_t,
            #[doc = "< Which parts of the shadow to draw"]
            pub type_: lv_shadow_type_t,
        }
        impl Default for lv_style_t__bindgen_ty_1__bindgen_ty_2 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[repr(C)]
        pub struct lv_style_t__bindgen_ty_1__bindgen_ty_3 {
            pub top: lv_coord_t,
            pub bottom: lv_coord_t,
            pub left: lv_coord_t,
            pub right: lv_coord_t,
            pub inner: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for
         lv_style_t__bindgen_ty_1__bindgen_ty_3 {
            #[inline]
            fn default() -> lv_style_t__bindgen_ty_1__bindgen_ty_3 {
                lv_style_t__bindgen_ty_1__bindgen_ty_3{top:
                                                           ::core::default::Default::default(),
                                                       bottom:
                                                           ::core::default::Default::default(),
                                                       left:
                                                           ::core::default::Default::default(),
                                                       right:
                                                           ::core::default::Default::default(),
                                                       inner:
                                                           ::core::default::Default::default(),}
            }
        }
        impl Default for lv_style_t__bindgen_ty_1 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = " Style for text drawn by this object."]
        #[repr(C)]
        pub struct lv_style_t__bindgen_ty_2 {
            #[doc = "< Text color"]
            pub color: lv_color_t,
            #[doc = "< Text selection background color."]
            pub sel_color: lv_color_t,
            pub font: *const lv_font_t,
            #[doc = "< Space between letters"]
            pub letter_space: lv_coord_t,
            #[doc = "< Space between lines (vertical)"]
            pub line_space: lv_coord_t,
            #[doc = "< Text opacity"]
            pub opa: lv_opa_t,
        }
        impl Default for lv_style_t__bindgen_ty_2 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[repr(C)]
        pub struct lv_style_t__bindgen_ty_3 {
            #[doc = "< Color to recolor the image with"]
            pub color: lv_color_t,
            #[doc = "< Opacity of recoloring (0 means no recoloring)"]
            pub intense: lv_opa_t,
            #[doc = "< Opacity of whole image"]
            pub opa: lv_opa_t,
        }
        impl Default for lv_style_t__bindgen_ty_3 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[repr(C)]
        pub struct lv_style_t__bindgen_ty_4 {
            pub color: lv_color_t,
            pub width: lv_coord_t,
            pub opa: lv_opa_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
        }
        impl Default for lv_style_t__bindgen_ty_4 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_t__bindgen_ty_4 {
            #[inline]
            pub fn rounded(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_rounded(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(rounded: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let rounded: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(rounded)
                                                    };
                                                rounded as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_res_t = u8;
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t
            =
            ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                        mask_p:
                                                            *const lv_area_t,
                                                        mode:
                                                            lv_design_mode_t)
                                       -> bool>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t
            =
            ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                        event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t
            =
            ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                        sign: lv_signal_t,
                                                        param:
                                                            *mut ::cty::c_void)
                                       -> lv_res_t>;
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_reailgn_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_reailgn_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_reailgn_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn origo_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_origo_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, origo_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let origo_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(origo_align)
                                                    };
                                                origo_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        #[doc = "< Expand the object size to the text size"]
        pub const LV_LABEL_LONG_EXPAND: _bindgen_ty_22 = 0;
        #[doc =
          "< Keep the object width, break the too long lines and expand the object"]
        #[doc = "height"]
        pub const LV_LABEL_LONG_BREAK: _bindgen_ty_22 = 1;
        #[doc =
          "< Keep the size and write dots at the end if the text is too long"]
        pub const LV_LABEL_LONG_DOT: _bindgen_ty_22 = 2;
        #[doc = "< Keep the size and roll the text back and forth"]
        pub const LV_LABEL_LONG_SROLL: _bindgen_ty_22 = 3;
        #[doc = "< Keep the size and roll the text circularly"]
        pub const LV_LABEL_LONG_SROLL_CIRC: _bindgen_ty_22 = 4;
        #[doc = "< Keep the size and crop the text out of it"]
        pub const LV_LABEL_LONG_CROP: _bindgen_ty_22 = 5;
        #[doc = " Long mode behaviors. Used in 'lv_label_ext_t'"]
        pub type _bindgen_ty_22 = u8;
        pub type lv_label_long_mode_t = u8;
        #[doc = "< Align text to left"]
        pub const LV_LABEL_ALIGN_LEFT: _bindgen_ty_23 = 0;
        #[doc = "< Align text to center"]
        pub const LV_LABEL_ALIGN_CENTER: _bindgen_ty_23 = 1;
        #[doc = "< Align text to right"]
        pub const LV_LABEL_ALIGN_RIGHT: _bindgen_ty_23 = 2;
        #[doc =
          "< Use LEFT or RIGHT depending on the direction of the text (LTR/RTL)"]
        pub const LV_LABEL_ALIGN_AUTO: _bindgen_ty_23 = 3;
        #[doc = " Label align policy"]
        pub type _bindgen_ty_23 = u8;
        pub type lv_label_align_t = u8;
        #[doc = " Data of label"]
        #[repr(C)]
        pub struct lv_label_ext_t {
            pub text: *mut ::cty::c_char,
            pub dot: lv_label_ext_t__bindgen_ty_1,
            pub dot_end: u16,
            pub offset: lv_point_t,
            pub anim_speed: u16,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
            pub __bindgen_padding_0: [u16; 3usize],
        }
        #[repr(C)]
        pub struct lv_label_ext_t__bindgen_ty_1 {
            pub tmp_ptr: __BindgenUnionField<*mut ::cty::c_char>,
            pub tmp: __BindgenUnionField<[::cty::c_char; 4usize]>,
            pub bindgen_union_field: u64,
        }
        impl Default for lv_label_ext_t__bindgen_ty_1 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl Default for lv_label_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_label_ext_t {
            #[inline]
            pub fn long_mode(&self) -> lv_label_long_mode_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_long_mode(&mut self, val: lv_label_long_mode_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn static_txt(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_static_txt(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn recolor(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_recolor(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn expand(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_expand(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn body_draw(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_body_draw(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn dot_tmp_alloc(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_dot_tmp_alloc(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(long_mode: lv_label_long_mode_t,
                                  static_txt: u8, align: u8, recolor: u8,
                                  expand: u8, body_draw: u8,
                                  dot_tmp_alloc: u8)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 3u8,
                                            {
                                                let long_mode: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(long_mode)
                                                    };
                                                long_mode as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let static_txt: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(static_txt)
                                                    };
                                                static_txt as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 2u8,
                                            {
                                                let align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(align)
                                                    };
                                                align as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let recolor: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(recolor)
                                                    };
                                                recolor as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let expand: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(expand)
                                                    };
                                                expand as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let body_draw: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(body_draw)
                                                    };
                                                body_draw as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let dot_tmp_alloc: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(dot_tmp_alloc)
                                                    };
                                                dot_tmp_alloc as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_LABEL_STYLE_MAIN: _bindgen_ty_24 = 0;
        #[doc = " Label styles"]
        pub type _bindgen_ty_24 = u8;
        pub type lv_label_style_t = u8;
        #[doc = " Create a label objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new label"]
        #[doc =
          " - __`copy`__: pointer to a button object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created button"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> LvglResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a label objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new label"]
                #[doc =
                  " - __`copy`__: pointer to a button object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created button"]
                pub fn lv_label_create(par: *mut lv_obj_t,
                                       copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_create(par as *mut lv_obj_t,
                                    copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Set a new text for a label. Memory will be allocated to store the text by the label."]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc =
          " - __`text`__: '\\0' terminated character string. NULL to refresh with the current text."]
        pub fn set_text(label: *mut lv_obj_t, text: &Strn) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set a new text for a label. Memory will be allocated to store the text by the label."]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " - __`text`__: '\\0' terminated character string. NULL to refresh with the current text."]
                pub fn lv_label_set_text(label: *mut lv_obj_t,
                                         text: *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            text.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_set_text(label as *mut lv_obj_t,
                                  text.as_ptr() as *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set a new formatted text for a label. Memory will be allocated to store the text by the label."]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc = " - __`fmt`__: `printf`-like format"]
        pub fn set_text_fmt(label: *mut lv_obj_t, fmt: &Strn)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set a new formatted text for a label. Memory will be allocated to store the text by the label."]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc = " - __`fmt`__: `printf`-like format"]
                pub fn lv_label_set_text_fmt(label: *mut lv_obj_t,
                                             fmt: *const ::cty::c_char, ...);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            fmt.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_set_text_fmt(label as *mut lv_obj_t,
                                      fmt.as_ptr() as *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set a new text for a label from a character array. The array don't has to be '\\0' terminated."]
        #[doc = " Memory will be allocated to store the array by the label."]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc =
          " - __`array`__: array of characters or NULL to refresh the label"]
        #[doc = " - __`size`__: the size of 'array' in bytes"]
        pub fn set_array_text(label: *mut lv_obj_t, array: &Strn, size: u16)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set a new text for a label from a character array. The array don't has to be '\\0' terminated."]
                #[doc =
                  " Memory will be allocated to store the array by the label."]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " - __`array`__: array of characters or NULL to refresh the label"]
                #[doc = " - __`size`__: the size of 'array' in bytes"]
                pub fn lv_label_set_array_text(label: *mut lv_obj_t,
                                               array: *const ::cty::c_char,
                                               size: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            array.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_set_array_text(label as *mut lv_obj_t,
                                        array.as_ptr() as
                                            *const ::cty::c_char,
                                        size as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set a static text. It will not be saved by the label so the 'text' variable"]
        #[doc = " has to be 'alive' while the label exist."]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc =
          " - __`text`__: pointer to a text. NULL to refresh with the current text."]
        pub fn set_static_text(label: *mut lv_obj_t, text: &Strn)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set a static text. It will not be saved by the label so the 'text' variable"]
                #[doc = " has to be 'alive' while the label exist."]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " - __`text`__: pointer to a text. NULL to refresh with the current text."]
                pub fn lv_label_set_static_text(label: *mut lv_obj_t,
                                                text: *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            text.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_set_static_text(label as *mut lv_obj_t,
                                         text.as_ptr() as
                                             *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the behavior of the label with longer text then the object size"]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc =
          " - __`long_mode`__: the new mode from 'lv_label_long_mode' enum."]
        #[doc =
          "                  In LV_LONG_BREAK/LONG/ROLL the size of the label should be set AFTER this"]
        #[doc = " function"]
        pub fn set_long_mode(label: *mut lv_obj_t,
                             long_mode: lv_label_long_mode_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the behavior of the label with longer text then the object size"]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " - __`long_mode`__: the new mode from 'lv_label_long_mode' enum."]
                #[doc =
                  "                  In LV_LONG_BREAK/LONG/ROLL the size of the label should be set AFTER this"]
                #[doc = " function"]
                pub fn lv_label_set_long_mode(label: *mut lv_obj_t,
                                              long_mode:
                                                  lv_label_long_mode_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_set_long_mode(label as *mut lv_obj_t,
                                       long_mode as lv_label_long_mode_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the align of the label (left or center)"]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc =
          " - __`align`__: 'LV_LABEL_ALIGN_LEFT' or 'LV_LABEL_ALIGN_LEFT'"]
        pub fn set_align(label: *mut lv_obj_t, align: lv_label_align_t)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the align of the label (left or center)"]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " - __`align`__: 'LV_LABEL_ALIGN_LEFT' or 'LV_LABEL_ALIGN_LEFT'"]
                pub fn lv_label_set_align(label: *mut lv_obj_t,
                                          align: lv_label_align_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_set_align(label as *mut lv_obj_t,
                                   align as lv_label_align_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Enable the recoloring by in-line commands"]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc = " - __`en`__: true: enable recoloring, false: disable"]
        pub fn set_recolor(label: *mut lv_obj_t, en: bool) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Enable the recoloring by in-line commands"]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " - __`en`__: true: enable recoloring, false: disable"]
                pub fn lv_label_set_recolor(label: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_set_recolor(label as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the label to draw (or not draw) background specified in its style's body"]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc = " - __`en`__: true: draw body; false: don't draw body"]
        pub fn set_body_draw(label: *mut lv_obj_t, en: bool)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the label to draw (or not draw) background specified in its style's body"]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " - __`en`__: true: draw body; false: don't draw body"]
                pub fn lv_label_set_body_draw(label: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_set_body_draw(label as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the label's animation speed in LV_LABEL_LONG_SROLL/SCROLL_CIRC modes"]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc = " - __`anim_speed`__: speed of animation in px/sec unit"]
        pub fn set_anim_speed(label: *mut lv_obj_t, anim_speed: u16)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the label's animation speed in LV_LABEL_LONG_SROLL/SCROLL_CIRC modes"]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " - __`anim_speed`__: speed of animation in px/sec unit"]
                pub fn lv_label_set_anim_speed(label: *mut lv_obj_t,
                                               anim_speed: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_set_anim_speed(label as *mut lv_obj_t,
                                        anim_speed as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the style of an label"]
        #[doc = " - __`label`__: pointer to an label object"]
        #[doc =
          " - __`type`__: which style should be get (can be only `LV_LABEL_STYLE_MAIN`)"]
        #[doc = " - __`style`__: pointer to a style"]
        pub fn set_style(label: *mut lv_obj_t, type_: lv_label_style_t,
                         style: *const lv_style_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the style of an label"]
                #[doc = " - __`label`__: pointer to an label object"]
                #[doc =
                  " - __`type`__: which style should be get (can be only `LV_LABEL_STYLE_MAIN`)"]
                #[doc = " - __`style`__: pointer to a style"]
                pub fn lv_label_set_style(label: *mut lv_obj_t,
                                          type_: lv_label_style_t,
                                          style: *const lv_style_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_set_style(label as *mut lv_obj_t,
                                   type_ as lv_label_style_t,
                                   style as *const lv_style_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " @brief Set the selection start index."]
        #[doc = " - __`label`__: pointer to a label object."]
        #[doc =
          " - __`index`__: index to set. `LV_LABEL_TXT_SEL_OFF` to select nothing."]
        pub fn set_text_sel_start(label: *mut lv_obj_t, index: u16)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " @brief Set the selection start index."]
                #[doc = " - __`label`__: pointer to a label object."]
                #[doc =
                  " - __`index`__: index to set. `LV_LABEL_TXT_SEL_OFF` to select nothing."]
                pub fn lv_label_set_text_sel_start(label: *mut lv_obj_t,
                                                   index: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_set_text_sel_start(label as *mut lv_obj_t,
                                            index as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " @brief Set the selection end index."]
        #[doc = " - __`label`__: pointer to a label object."]
        #[doc =
          " - __`index`__: index to set. `LV_LABEL_TXT_SEL_OFF` to select nothing."]
        pub fn set_text_sel_end(label: *mut lv_obj_t, index: u16)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " @brief Set the selection end index."]
                #[doc = " - __`label`__: pointer to a label object."]
                #[doc =
                  " - __`index`__: index to set. `LV_LABEL_TXT_SEL_OFF` to select nothing."]
                pub fn lv_label_set_text_sel_end(label: *mut lv_obj_t,
                                                 index: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_set_text_sel_end(label as *mut lv_obj_t,
                                          index as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the text of a label"]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc = " Return: the text of the label"]
        pub fn get_text(label: *const lv_obj_t)
         -> LvglResult<*mut ::cty::c_char> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the text of a label"]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc = " Return: the text of the label"]
                pub fn lv_label_get_text(label: *const lv_obj_t)
                -> *mut ::cty::c_char;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_get_text(label as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the long mode of a label"]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc = " Return: the long mode"]
        pub fn get_long_mode(label: *const lv_obj_t)
         -> LvglResult<lv_label_long_mode_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the long mode of a label"]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc = " Return: the long mode"]
                pub fn lv_label_get_long_mode(label: *const lv_obj_t)
                -> lv_label_long_mode_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_get_long_mode(label as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the align attribute"]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc = " Return: LV_LABEL_ALIGN_LEFT or LV_LABEL_ALIGN_CENTER"]
        pub fn get_align(label: *const lv_obj_t)
         -> LvglResult<lv_label_align_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the align attribute"]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " Return: LV_LABEL_ALIGN_LEFT or LV_LABEL_ALIGN_CENTER"]
                pub fn lv_label_get_align(label: *const lv_obj_t)
                -> lv_label_align_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_get_align(label as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the recoloring attribute"]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc = " Return: true: recoloring is enabled, false: disable"]
        pub fn get_recolor(label: *const lv_obj_t) -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the recoloring attribute"]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " Return: true: recoloring is enabled, false: disable"]
                pub fn lv_label_get_recolor(label: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_get_recolor(label as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the body draw attribute"]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc = " Return: true: draw body; false: don't draw body"]
        pub fn get_body_draw(label: *const lv_obj_t) -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the body draw attribute"]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc = " Return: true: draw body; false: don't draw body"]
                pub fn lv_label_get_body_draw(label: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_get_body_draw(label as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get the label's animation speed in LV_LABEL_LONG_ROLL and SCROLL modes"]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc = " Return: speed of animation in px/sec unit"]
        pub fn get_anim_speed(label: *const lv_obj_t) -> LvglResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the label's animation speed in LV_LABEL_LONG_ROLL and SCROLL modes"]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc = " Return: speed of animation in px/sec unit"]
                pub fn lv_label_get_anim_speed(label: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_get_anim_speed(label as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the relative x and y coordinates of a letter"]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc =
          " - __`index`__: index of the letter [0 ... text length]. Expressed in character index, not byte"]
        #[doc = " index (different in UTF-8)"]
        #[doc =
          " - __`pos`__: store the result here (E.g. index = 0 gives 0;0 coordinates)"]
        pub fn get_letter_pos(label: *const lv_obj_t, index: u16,
                              pos: *mut lv_point_t) -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the relative x and y coordinates of a letter"]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " - __`index`__: index of the letter [0 ... text length]. Expressed in character index, not byte"]
                #[doc = " index (different in UTF-8)"]
                #[doc =
                  " - __`pos`__: store the result here (E.g. index = 0 gives 0;0 coordinates)"]
                pub fn lv_label_get_letter_pos(label: *const lv_obj_t,
                                               index: u16,
                                               pos: *mut lv_point_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_get_letter_pos(label as *const lv_obj_t,
                                        index as u16, pos as *mut lv_point_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the index of letter on a relative point of a label"]
        #[doc = " - __`label`__: pointer to label object"]
        #[doc =
          " - __`pos`__: pointer to point with coordinates on a the label"]
        #[doc =
          " Return: the index of the letter on the 'pos_p' point (E.g. on 0;0 is the 0. letter)"]
        #[doc =
          " Expressed in character index and not byte index (different in UTF-8)"]
        pub fn get_letter_on(label: *const lv_obj_t, pos: *mut lv_point_t)
         -> LvglResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the index of letter on a relative point of a label"]
                #[doc = " - __`label`__: pointer to label object"]
                #[doc =
                  " - __`pos`__: pointer to point with coordinates on a the label"]
                #[doc =
                  " Return: the index of the letter on the 'pos_p' point (E.g. on 0;0 is the 0. letter)"]
                #[doc =
                  " Expressed in character index and not byte index (different in UTF-8)"]
                pub fn lv_label_get_letter_on(label: *const lv_obj_t,
                                              pos: *mut lv_point_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_get_letter_on(label as *const lv_obj_t,
                                           pos as *mut lv_point_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Check if a character is drawn under a point."]
        #[doc = " - __`label`__: Label object"]
        #[doc = " - __`pos`__: Point to check for characte under"]
        #[doc = " Return: whether a character is drawn under the point"]
        pub fn is_char_under_pos(label: *const lv_obj_t, pos: *mut lv_point_t)
         -> LvglResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Check if a character is drawn under a point."]
                #[doc = " - __`label`__: Label object"]
                #[doc = " - __`pos`__: Point to check for characte under"]
                #[doc =
                  " Return: whether a character is drawn under the point"]
                pub fn lv_label_is_char_under_pos(label: *const lv_obj_t,
                                                  pos: *mut lv_point_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_is_char_under_pos(label as *const lv_obj_t,
                                               pos as *mut lv_point_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the style of an label object"]
        #[doc = " - __`label`__: pointer to an label object"]
        #[doc =
          " - __`type`__: which style should be get (can be only `LV_LABEL_STYLE_MAIN`)"]
        #[doc = " Return: pointer to the label's style"]
        pub fn get_style(label: *const lv_obj_t, type_: lv_label_style_t)
         -> LvglResult<*const lv_style_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the style of an label object"]
                #[doc = " - __`label`__: pointer to an label object"]
                #[doc =
                  " - __`type`__: which style should be get (can be only `LV_LABEL_STYLE_MAIN`)"]
                #[doc = " Return: pointer to the label's style"]
                pub fn lv_label_get_style(label: *const lv_obj_t,
                                          type_: lv_label_style_t)
                -> *const lv_style_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_get_style(label as *const lv_obj_t,
                                       type_ as lv_label_style_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " @brief Get the selection start index."]
        #[doc = " - __`label`__: pointer to a label object."]
        #[doc =
          " Return: selection start index. `LV_LABEL_TXT_SEL_OFF` if nothing is selected."]
        pub fn get_text_sel_start(label: *const lv_obj_t) -> LvglResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " @brief Get the selection start index."]
                #[doc = " - __`label`__: pointer to a label object."]
                #[doc =
                  " Return: selection start index. `LV_LABEL_TXT_SEL_OFF` if nothing is selected."]
                pub fn lv_label_get_text_sel_start(label: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_get_text_sel_start(label as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " @brief Get the selection end index."]
        #[doc = " - __`label`__: pointer to a label object."]
        #[doc =
          " Return: selection end index. `LV_LABEL_TXT_SEL_OFF` if nothing is selected."]
        pub fn get_text_sel_end(label: *const lv_obj_t) -> LvglResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " @brief Get the selection end index."]
                #[doc = " - __`label`__: pointer to a label object."]
                #[doc =
                  " Return: selection end index. `LV_LABEL_TXT_SEL_OFF` if nothing is selected."]
                pub fn lv_label_get_text_sel_end(label: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_get_text_sel_end(label as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Insert a text to the label. The label text can not be static."]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc =
          " - __`pos`__: character index to insert. Expressed in character index and not byte index (Different"]
        #[doc =
          " in UTF-8) 0: before first char. LV_LABEL_POS_LAST: after last char."]
        #[doc = " - __`txt`__: pointer to the text to insert"]
        pub fn ins_text(label: *mut lv_obj_t, pos: u32, txt: &Strn)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Insert a text to the label. The label text can not be static."]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " - __`pos`__: character index to insert. Expressed in character index and not byte index (Different"]
                #[doc =
                  " in UTF-8) 0: before first char. LV_LABEL_POS_LAST: after last char."]
                #[doc = " - __`txt`__: pointer to the text to insert"]
                pub fn lv_label_ins_text(label: *mut lv_obj_t, pos: u32,
                                         txt: *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            txt.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_ins_text(label as *mut lv_obj_t, pos as u32,
                                  txt.as_ptr() as *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Delete characters from a label. The label text can not be static."]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc =
          " - __`pos`__: character index to insert. Expressed in character index and not byte index (Different"]
        #[doc = " in UTF-8) 0: before first char."]
        #[doc = " - __`cnt`__: number of characters to cut"]
        pub fn cut_text(label: *mut lv_obj_t, pos: u32, cnt: u32)
         -> LvglResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Delete characters from a label. The label text can not be static."]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " - __`pos`__: character index to insert. Expressed in character index and not byte index (Different"]
                #[doc = " in UTF-8) 0: before first char."]
                #[doc = " - __`cnt`__: number of characters to cut"]
                pub fn lv_label_cut_text(label: *mut lv_obj_t, pos: u32,
                                         cnt: u32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_cut_text(label as *mut lv_obj_t, pos as u32,
                                  cnt as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
    }
}
#[macro_use]
pub mod util {
    //! LittlevGL (LVGL) Utility Macros for Rust
    #[macro_use]
    pub mod macros {
        //!  Mynewt Macros for Rust. Note that macros defined locally should be called with `$crate::`, like `$crate::parse`.
        //!  This works with Rust compiler versions 1.30 and later.  See https://doc.rust-lang.org/stable/edition-guide/rust-2018/macros/macro-changes.html
        //!  To see the expanded macros: `cargo rustc -- -Z unstable-options --pretty expanded`
        ///  Return a const struct that has all fields set to 0. Used for initialising static mutable structs like `os_task`.
        ///  `fill_zero!(os::os_task)` expands to
        ///  ```
        /// unsafe { 
        ///	::core::mem::transmute::
        ///	<
        ///	  [
        ///		u8; 
        ///		::core::mem::size_of::<os::os_task>()
        ///	  ], 
        ///	  os::os_task
        ///	>
        ///	(
        ///	  [
        ///		0; 
        ///		::core::mem::size_of::<os::os_task>()
        ///	  ]
        ///	) 
        /// }
        ///  ```
        #[macro_export]
        macro_rules! fill_zero {
            ($ ($ tts : tt) *) =>
            {
                unsafe
                {
                    :: core :: mem :: transmute :: <
                    [u8 ; :: core :: mem :: size_of :: < $ ($ tts) * > ()], $
                    ($ tts) * >
                    ([0 ; :: core :: mem :: size_of :: < $ ($ tts) * > ()])
                }
            } ;
        }
        ///  Macro that takes an identifier and returns a `[u8]` containing the identifier, terminated by 0.
        ///  Used to convert an identifier to a C null-terminated string.
        #[macro_export]
        macro_rules! stringify_null {
            ($ key : ident) => { concat ! (stringify ! ($ key), "\0") } ;
        }
        ///  Macro to dump all tokens received as a literal string, e.g.
        ///  `d!(a b c)` returns `"a b c"`
        #[macro_export]
        macro_rules! d {
            ($ ($ token : tt) *) => { stringify ! ($ ($ token) *) } ;
        }
        ///  Macro to display the token being parsed and the remaining tokens
        #[macro_export]
        macro_rules! nx {
            (($ ($ current : tt) *), ($ ($ next : tt) *), ($ ($ rest : tt) *))
            =>
            {
                concat !
                (" >> ", stringify ! ($ ($ current) *), " >> ", stringify !
                 ($ ($ next) *), " >> ", stringify ! ($ ($ rest) *)) ;
            } ;
        }
    }
}
pub mod console {
    //! Display messages on Arm Semihosting Console (via OpenOCD)
    extern crate cortex_m_semihosting;
    use cortex_m_semihosting::hio;
    use core::fmt::Write;
    ///  Display message `msg` on the Arm Semihosting console (via OpenOCD).
    pub fn print(msg: &str) {
        let mut stderr =
            match hio::hstderr() {
                Ok(fd) => fd,
                Err(()) => {
                    if !false { ::core::panicking::panic("stderr fail") };
                    return;
                }
            };
        stderr.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                        &match (&msg,) {
                                                             (arg0,) =>
                                                             [::core::fmt::ArgumentV1::new(arg0,
                                                                                           ::core::fmt::Display::fmt)],
                                                         })).expect("print fail");
    }
    ///  Add the string to the output buffer.
    pub fn buffer(msg: &str) {
        let mut stderr =
            match hio::hstderr() {
                Ok(fd) => fd,
                Err(()) => {
                    if !false { ::core::panicking::panic("stderr fail") };
                    return;
                }
            };
        stderr.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                        &match (&msg,) {
                                                             (arg0,) =>
                                                             [::core::fmt::ArgumentV1::new(arg0,
                                                                                           ::core::fmt::Display::fmt)],
                                                         })).expect("buffer fail");
    }
    ///  Write a byte in hexadecimal to the output buffer.
    pub fn printhex(v: u8) {
        let mut stderr =
            match hio::hstderr() {
                Ok(fd) => fd,
                Err(()) => {
                    if !false { ::core::panicking::panic("stderr fail") };
                    return;
                }
            };
        stderr.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                        &match (&v,) {
                                                             (arg0,) =>
                                                             [::core::fmt::ArgumentV1::new(arg0,
                                                                                           ::core::fmt::LowerHex::fmt)],
                                                         })).expect("printhex fail");
    }
    ///  Write an int to the output buffer.
    pub fn printint(v: i32) {
        let mut stderr =
            match hio::hstderr() {
                Ok(fd) => fd,
                Err(()) => {
                    if !false { ::core::panicking::panic("stderr fail") };
                    return;
                }
            };
        stderr.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                        &match (&v,) {
                                                             (arg0,) =>
                                                             [::core::fmt::ArgumentV1::new(arg0,
                                                                                           ::core::fmt::Display::fmt)],
                                                         })).expect("printint fail");
    }
    ///  Write a float to the output buffer, with 2 decimal places.
    pub fn printfloat(v: f32) {
        let mut stderr =
            match hio::hstderr() {
                Ok(fd) => fd,
                Err(()) => {
                    if !false { ::core::panicking::panic("stderr fail") };
                    return;
                }
            };
        stderr.write_fmt(::core::fmt::Arguments::new_v1_formatted(&[""],
                                                                  &match (&v,)
                                                                       {
                                                                       (arg0,)
                                                                       =>
                                                                       [::core::fmt::ArgumentV1::new(arg0,
                                                                                                     ::core::fmt::Display::fmt)],
                                                                   },
                                                                  &[::core::fmt::rt::v1::Argument{position:
                                                                                                      0usize,
                                                                                                  format:
                                                                                                      ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                          ' ',
                                                                                                                                      align:
                                                                                                                                          ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                      flags:
                                                                                                                                          0u32,
                                                                                                                                      precision:
                                                                                                                                          ::core::fmt::rt::v1::Count::Is(2usize),
                                                                                                                                      width:
                                                                                                                                          ::core::fmt::rt::v1::Count::Implied,},}])).expect("printfloat fail");
    }
    ///  Write a double to the output buffer, with 6 decimal places.
    pub fn printdouble(v: f64) {
        let mut stderr =
            match hio::hstderr() {
                Ok(fd) => fd,
                Err(()) => {
                    if !false { ::core::panicking::panic("stderr fail") };
                    return;
                }
            };
        stderr.write_fmt(::core::fmt::Arguments::new_v1_formatted(&[""],
                                                                  &match (&v,)
                                                                       {
                                                                       (arg0,)
                                                                       =>
                                                                       [::core::fmt::ArgumentV1::new(arg0,
                                                                                                     ::core::fmt::Display::fmt)],
                                                                   },
                                                                  &[::core::fmt::rt::v1::Argument{position:
                                                                                                      0usize,
                                                                                                  format:
                                                                                                      ::core::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                          ' ',
                                                                                                                                      align:
                                                                                                                                          ::core::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                      flags:
                                                                                                                                          0u32,
                                                                                                                                      precision:
                                                                                                                                          ::core::fmt::rt::v1::Count::Is(6usize),
                                                                                                                                      width:
                                                                                                                                          ::core::fmt::rt::v1::Count::Implied,},}])).expect("printint fail");
    }
    ///  Flush the output buffer to the console.
    pub fn flush() { }
}
/// Return type and error codes for Lvgl API
pub mod result {
    /// Common return type for Lvgl API.  If no error, returns `Ok(val)` where val has type T.
    /// Upon error, returns `Err(err)` where err is the LvglError error code.
    pub type LvglResult<T> = ::core::result::Result<T, LvglError>;
    /// Error codes for Lvgl API
    #[repr(i32)]
    #[allow(non_camel_case_types)]
    pub enum LvglError {

        /// Error code 0 means no error.
        SYS_EOK = 0,
        SYS_EUNKNOWN = 1,
    }
    #[allow(non_camel_case_types)]
    impl ::core::marker::StructuralPartialEq for LvglError { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::PartialEq for LvglError {
        #[inline]
        fn eq(&self, other: &LvglError) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) }
                        as i32;
                let __arg_1_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*other) }
                        as i32;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) { _ => true, }
                } else { false }
            }
        }
    }
    /// Cast `LvglError` to `i32`
    impl From<LvglError> for i32 {
        /// Cast `LvglError` to `i32`
        fn from(err: LvglError) -> Self { err as i32 }
    }
    /// Cast `i32` to `LvglError`
    impl From<i32> for LvglError {
        /// Cast `i32` to `LvglError`
        fn from(num: i32) -> Self {
            unsafe { ::core::mem::transmute::<i32, LvglError>(num) }
        }
    }
    /// Cast `()` to `LvglError`
    impl From<()> for LvglError {
        /// Cast `()` to `LvglError`
        fn from(_: ()) -> Self { LvglError::SYS_EUNKNOWN }
    }
    /// Implement formatted output for LvglError
    impl core::fmt::Debug for LvglError {
        fn fmt(&self, _fmt: &mut ::core::fmt::Formatter<'_>)
         -> ::core::fmt::Result {
            Ok(())
        }
    }
}
/// Represents a null-terminated string, suitable for passing to Lvgl APIs as `* const char`.
/// The string could be a null-terminated byte string created in Rust, or a pointer to a null-terminated string returned by C.
/// Pointer may be null.
pub struct Strn {
    /// Either a byte string terminated with null, or a pointer to a null-terminated string
    pub rep: StrnRep,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for Strn {
    #[inline]
    fn clone(&self) -> Strn {
        { let _: ::core::clone::AssertParamIsClone<StrnRep>; *self }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::marker::Copy for Strn { }
/// Either a byte string or a string pointer
#[repr(u8)]
pub enum StrnRep {

    /// Byte string terminated with null
    ByteStr(&'static [u8]),

    /// Pointer to a null-terminated string
    CStr(*const u8),
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for StrnRep {
    #[inline]
    fn clone(&self) -> StrnRep {
        {
            let _: ::core::clone::AssertParamIsClone<&'static [u8]>;
            let _: ::core::clone::AssertParamIsClone<*const u8>;
            *self
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::marker::Copy for StrnRep { }
impl Strn {
    /// Create a new `Strn` with a byte string. Fail if the last byte is not zero.
    /// ```
    /// Strn::new(b"network\0")
    /// strn!("network")
    /// ```
    pub fn new(bs: &'static [u8]) -> Strn {
        {
            match (&(bs.last()), &(Some(&0u8))) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(&["assertion failed: `(left == right)`\n  left: `",
                                                                                      "`,\n right: `",
                                                                                      "`: "],
                                                                                    &match (&&*left_val,
                                                                                            &&*right_val,
                                                                                            &::core::fmt::Arguments::new_v1(&["no null"],
                                                                                                                            &match ()
                                                                                                                                 {
                                                                                                                                 ()
                                                                                                                                 =>
                                                                                                                                 [],
                                                                                                                             }))
                                                                                         {
                                                                                         (arg0,
                                                                                          arg1,
                                                                                          arg2)
                                                                                         =>
                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                       ::core::fmt::Debug::fmt),
                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                       ::core::fmt::Debug::fmt),
                                                                                          ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                     }),
                                                     ::core::panic::Location::caller())
                    }
                }
            }
        };
        Strn{rep: StrnRep::ByteStr(bs),}
    }
    /// Create a new `Strn` with a null-terminated string pointer returned by C.
    pub fn from_cstr(cstr: *const u8) -> Strn {
        Strn{rep: StrnRep::CStr(cstr),}
    }
    /// Return a pointer to the string
    pub fn as_ptr(&self) -> *const u8 {
        match self.rep {
            StrnRep::ByteStr(bs) => { bs.as_ptr() }
            StrnRep::CStr(cstr) => { cstr }
        }
    }
    /// Return the length of the string, excluding the terminating null. For safety, we limit to 128.
    pub fn len(&self) -> usize {
        match self.rep {
            StrnRep::ByteStr(bs) => {
                {
                    match (&(bs.last()), &(Some(&0u8))) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(&["assertion failed: `(left == right)`\n  left: `",
                                                                                              "`,\n right: `",
                                                                                              "`: "],
                                                                                            &match (&&*left_val,
                                                                                                    &&*right_val,
                                                                                                    &::core::fmt::Arguments::new_v1(&["no null"],
                                                                                                                                    &match ()
                                                                                                                                         {
                                                                                                                                         ()
                                                                                                                                         =>
                                                                                                                                         [],
                                                                                                                                     }))
                                                                                                 {
                                                                                                 (arg0,
                                                                                                  arg1,
                                                                                                  arg2)
                                                                                                 =>
                                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                               ::core::fmt::Debug::fmt),
                                                                                                  ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                               ::core::fmt::Debug::fmt),
                                                                                                  ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                               ::core::fmt::Display::fmt)],
                                                                                             }),
                                                             ::core::panic::Location::caller())
                            }
                        }
                    }
                };
                bs.len() - 1
            }
            StrnRep::CStr(cstr) => {
                if cstr.is_null() { return 0; }
                for len in 0..127 {
                    let ptr: *const u8 = ((cstr as u32) + len) as *const u8;
                    if unsafe { *ptr } == 0 { return len as usize; }
                }
                if !false { ::core::panicking::panic("big strn") };
                return 128 as usize;
            }
        }
    }
    /// Return true if the string is empty
    pub fn is_empty(&self) -> bool { self.len() == 0 }
    /// Return the byte string as a null-terminated `* const char` C-style string.
    /// Fail if the last byte is not zero.
    pub fn as_cstr(&self) -> *const u8 {
        match self.rep {
            StrnRep::ByteStr(bs) => {
                {
                    match (&(bs.last()), &(Some(&0u8))) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(&["assertion failed: `(left == right)`\n  left: `",
                                                                                              "`,\n right: `",
                                                                                              "`: "],
                                                                                            &match (&&*left_val,
                                                                                                    &&*right_val,
                                                                                                    &::core::fmt::Arguments::new_v1(&["no null"],
                                                                                                                                    &match ()
                                                                                                                                         {
                                                                                                                                         ()
                                                                                                                                         =>
                                                                                                                                         [],
                                                                                                                                     }))
                                                                                                 {
                                                                                                 (arg0,
                                                                                                  arg1,
                                                                                                  arg2)
                                                                                                 =>
                                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                               ::core::fmt::Debug::fmt),
                                                                                                  ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                               ::core::fmt::Debug::fmt),
                                                                                                  ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                               ::core::fmt::Display::fmt)],
                                                                                             }),
                                                             ::core::panic::Location::caller())
                            }
                        }
                    }
                };
                bs.as_ptr() as *const u8
            }
            StrnRep::CStr(cstr) => { cstr }
        }
    }
    /// Return the byte string.
    /// Fail if the last byte is not zero.
    pub fn as_bytestr(&self) -> &'static [u8] {
        match self.rep {
            StrnRep::ByteStr(bs) => {
                {
                    match (&(bs.last()), &(Some(&0u8))) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(&["assertion failed: `(left == right)`\n  left: `",
                                                                                              "`,\n right: `",
                                                                                              "`: "],
                                                                                            &match (&&*left_val,
                                                                                                    &&*right_val,
                                                                                                    &::core::fmt::Arguments::new_v1(&["no null"],
                                                                                                                                    &match ()
                                                                                                                                         {
                                                                                                                                         ()
                                                                                                                                         =>
                                                                                                                                         [],
                                                                                                                                     }))
                                                                                                 {
                                                                                                 (arg0,
                                                                                                  arg1,
                                                                                                  arg2)
                                                                                                 =>
                                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                               ::core::fmt::Debug::fmt),
                                                                                                  ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                               ::core::fmt::Debug::fmt),
                                                                                                  ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                               ::core::fmt::Display::fmt)],
                                                                                             }),
                                                             ::core::panic::Location::caller())
                            }
                        }
                    }
                };
                &bs
            }
            StrnRep::CStr(_cstr) => {
                if !false { ::core::panicking::panic("strn cstr") };
                b"\0"
            }
        }
    }
    /// Fail if the last byte is not zero.
    pub fn validate(&self) {
        match self.rep {
            StrnRep::ByteStr(bs) => {
                {
                    match (&(bs.last()), &(Some(&0u8))) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(&["assertion failed: `(left == right)`\n  left: `",
                                                                                              "`,\n right: `",
                                                                                              "`: "],
                                                                                            &match (&&*left_val,
                                                                                                    &&*right_val,
                                                                                                    &::core::fmt::Arguments::new_v1(&["no null"],
                                                                                                                                    &match ()
                                                                                                                                         {
                                                                                                                                         ()
                                                                                                                                         =>
                                                                                                                                         [],
                                                                                                                                     }))
                                                                                                 {
                                                                                                 (arg0,
                                                                                                  arg1,
                                                                                                  arg2)
                                                                                                 =>
                                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                               ::core::fmt::Debug::fmt),
                                                                                                  ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                               ::core::fmt::Debug::fmt),
                                                                                                  ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                               ::core::fmt::Display::fmt)],
                                                                                             }),
                                                             ::core::panic::Location::caller())
                            }
                        }
                    }
                };
            }
            StrnRep::CStr(_cstr) => { }
        }
    }
    /// Fail if the last byte is not zero.
    pub fn validate_bytestr(bs: &'static [u8]) {
        {
            match (&(bs.last()), &(Some(&0u8))) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(&["assertion failed: `(left == right)`\n  left: `",
                                                                                      "`,\n right: `",
                                                                                      "`: "],
                                                                                    &match (&&*left_val,
                                                                                            &&*right_val,
                                                                                            &::core::fmt::Arguments::new_v1(&["no null"],
                                                                                                                            &match ()
                                                                                                                                 {
                                                                                                                                 ()
                                                                                                                                 =>
                                                                                                                                 [],
                                                                                                                             }))
                                                                                         {
                                                                                         (arg0,
                                                                                          arg1,
                                                                                          arg2)
                                                                                         =>
                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                       ::core::fmt::Debug::fmt),
                                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                       ::core::fmt::Debug::fmt),
                                                                                          ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                     }),
                                                     ::core::panic::Location::caller())
                    }
                }
            }
        };
    }
}
///  Allow threads to share Strn, since it is static.
unsafe impl Send for Strn { }
///  Allow threads to share Strn, since it is static.
unsafe impl Sync for Strn { }
///  Declare a pointer that will be used by C functions to return a value
pub type Out<T> = &'static mut T;
///  Declare a `void *` pointer that will be passed to C functions
pub type Ptr = *mut ::cty::c_void;
///  Declare a `NULL` pointer that will be passed to C functions
pub const NULL: Ptr = ::core::ptr::null_mut();
